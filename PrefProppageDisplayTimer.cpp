//
// *********************************************************
// *                                                       *
// * Copyright 1998-2022, Lazerus Laser Systems            *
// * Author: Michael G. Svob                               *
// *                                                       *
// * File Name: PrefProppageDisplayTimer.cpp               *
// * Description: Implementation of the                    *
// * CPrefProppageDisplayTimer class, which is the Display *
// * Timer property page.                                  *
// *                                                       *
// * NOTE: This file was generated by MS Visual Studio,    *
// *       and modified by the author as necessary for     *
// *       the LFI Player application.
// *                                                       *
// * This code is distributed under the GNU Public License *
// * which can be found at...                              *
// *                                                       *
// * http://www.gnu.org/licenses/gpl.txt                   *
// *                                                       *
// *********************************************************
//

#include "stdafx.h"
#include "Cheap3D.h"
#include "PrefProppageDisplayTimer.h"
#include "Cheap3DView.h"
#include <iostream>
#include <fstream>
#include <cmath>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

using namespace std; 

extern ofstream logFile;

/////////////////////////////////////////////////////////////////////////////
// CPrefProppageDisplayTimer property page

IMPLEMENT_DYNCREATE(CPrefProppageDisplayTimer, CPropertyPage)

CPrefProppageDisplayTimer::CPrefProppageDisplayTimer() : CPropertyPage(CPrefProppageDisplayTimer::IDD)
{
	//{{AFX_DATA_INIT(CPrefProppageDisplayTimer)
	m_EditDisplayTimerValue = 1;
    m_EditPointsPerSecond = 1000;
	//}}AFX_DATA_INIT

}

CPrefProppageDisplayTimer::~CPrefProppageDisplayTimer()
{
}

BOOL CPrefProppageDisplayTimer::OnSetActive() 
{
    m_SliderPointsPerSecond.SetRange(MIN_PPS, MAX_PPS);
	m_SliderPointsPerSecond.SetTicFreq(10000);
    m_SliderDisplayTimerValue.SetRange(MIN_DISPLAY_TIMER_VALUE, MAX_DISPLAY_TIMER_VALUE);
	m_SliderDisplayTimerValue.SetTicFreq(100);

    m_EditPointsPerSecond = parentPtr->outputPPS;
//    m_EditPointsPerSecond = (UINT)(1.0 / ((double)(parentPtr->outputDelayPeriod) * 0.00000003));
    
	m_SliderPointsPerSecond.SetPos(m_EditPointsPerSecond);
    m_EditDisplayTimerValue = parentPtr->displayTimerValue;
    m_SliderDisplayTimerValue.SetPos(m_EditDisplayTimerValue);

	UpdateData(FALSE);

	return true;
}

void CPrefProppageDisplayTimer::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPrefProppageDisplayTimer)
	DDX_Control(pDX, IDC_SLIDER_POINTS_PER_SECOND, m_SliderPointsPerSecond);
	DDX_Control(pDX, IDC_SLIDER_DISPLAY_TIMER_VALUE, m_SliderDisplayTimerValue);
	DDX_Text(pDX, IDC_EDIT_POINTS_PER_SECOND, m_EditPointsPerSecond);
	DDX_Text(pDX, IDC_EDIT_DISPLAY_TIMER_VALUE, m_EditDisplayTimerValue);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPrefProppageDisplayTimer, CPropertyPage)
	//{{AFX_MSG_MAP(CPrefProppageDisplayTimer)
	ON_WM_HSCROLL()	
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPrefProppageDisplayTimer message handlers

void CPrefProppageDisplayTimer::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar) 
{
    m_EditPointsPerSecond = m_SliderPointsPerSecond.GetPos();
//	parentPtr->outputDelayPeriod = (UINT)((1.0/(double)m_EditPointsPerSecond)/0.00000003);
    parentPtr->outputPPS = m_EditPointsPerSecond;

	for(M_UINT8 s=0 ; s<MAX_TRACKS ; ++s)
    {
        if(parentPtr->outputDeviceArray[s])
        {
            if(parentPtr->outputDeviceArray[s]->GetOutputDeviceType() == RIYA)
            {
                // HINT CONCERNING FOLLOWING: According to Riya documentation...
                // "Scan rate 0x3C..0xFFFF  (2880..1966050 ns) - 0x1 = 30nsec"
                M_UINT32 tempDelayPeriod = (UINT)((1.0/(double)m_EditPointsPerSecond)/0.00000003); 
                ((Device_RIYA*)(parentPtr->outputDeviceArray[s]))->SetDelayPeriod(tempDelayPeriod);
            }
            else if (parentPtr->outputDeviceArray[s]->GetOutputDeviceType() == EZAUDDAC)
            {
                ((Device_EZAUDDAC*)(parentPtr->outputDeviceArray[s]))->SetOutputPPS(m_EditPointsPerSecond);
            }
            else if (parentPtr->outputDeviceArray[s]->GetOutputDeviceType() == EASYLASE)
            {
                ((Device_EASYLASE*)(parentPtr->outputDeviceArray[s]))->SetOutputPPS(m_EditPointsPerSecond);
            }
        } 
    }

//    parentPtr->SetDelayPeriodValue( (UINT)((1.0/(double)m_EditPointsPerSecond)/0.00000003) ); 

// logFile << "RIYA period is " << parentPtr->GetRiyaPeriodValue() << endl;

    m_EditDisplayTimerValue = m_SliderDisplayTimerValue.GetPos();
    parentPtr->SetDisplayTimerValue(m_EditDisplayTimerValue);

	if(parentPtr->displayTimerSet == TRUE)
	{
	    parentPtr->KillTimer(DISPLAY_TIMER);
	    // Re-install system timer
	    if (!(parentPtr->SetTimer(DISPLAY_TIMER, parentPtr->GetDisplayTimerValue(), NULL)))
		{
	        parentPtr->MessageBox("Preferences: Can't re-install DISPLAY_TIMER.");
		}
    }

	UpdateData(FALSE);

}


