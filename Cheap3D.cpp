//
// *********************************************************
// *                                                       *
// * Copyright 1998-2022, Lazerus Laser Systems            *
// * Author: Michael G. Svob                               *
// *                                                       *
// * File Name: Cheap3D.cpp                                *
// * Description: Defines the class behaviors for the      *
// * LFI_Player application.                               *
// *                                                       *
// * NOTE: This file was generated by MS Visual Studio,    *
// *       and modified by the author as necessary for     *
// *       the LFI Player application.
// *                                                       *
// * This code is distributed under the GNU Public License *
// * which can be found at...                              *
// *                                                       *
// * http://www.gnu.org/licenses/gpl.txt                   *
// *                                                       *
// *********************************************************
//

#include <iostream>
#include <fstream>
#include <direct.h>

#include "stdafx.h"
#include "Cheap3D.h"

#include "MainFrm.h"
#include "CommandLine.h"
#include "Cheap3DDoc.h"
#include "Cheap3DView.h"
#include "resource.h"
// #include "vld.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

using namespace std; 

//////////////////////////////////////////////////////////////////////
//                 APPLICATION GLOBAL VARIABLES                      
//////////////////////////////////////////////////////////////////////

// These are here because either the variables need to be accessed
// by a wide range of objects, and it would have been a pain to pass
// them around, or because on start-up, the relationship between the
// "app" and the associated "view" isn't fully defined, and we need
// to pass data between the two.  Knowing what I know now, I'd probably
// restructure the whole damn program...but it's kind of late in the
// game for that sort of thing :-(
ofstream           logFile;
char               appDirName[_MAX_PATH];
CommandLineInfo_T  appCmdLineInfo;

#if defined(_DEBUG)
    CMemoryState msStart;
    CMemoryState msEnd;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCheap3DApp

BEGIN_MESSAGE_MAP(CCheap3DApp, CWinApp)
    //{{AFX_MSG_MAP(CCheap3DApp)
    ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
//	ON_COMMAND(ID_OPEN_ILDA_FILE, OnOpenIldaFile)
    //}}AFX_MSG_MAP
    // Standard file based document commands
    ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
    ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCheap3DApp construction

CCheap3DApp::CCheap3DApp()
{
    // TODO: add construction code here,
    // Place all significant initialization in InitInstance
#if defined(_DEBUG)
    msStart.Checkpoint();
#endif
}

CCheap3DApp::~CCheap3DApp()
{
    try
    {
#if defined(_DEBUG)
        msEnd.Checkpoint();
        msStart.DumpAllObjectsSince();
#endif
        logFile.flush();
        logFile.close();

        // CMemoryState msOld;
        // msOld.Checkpoint();
        // CAge* page1 = new CAge( 21 );
        // CAge* page2 = new CAge( 22 );
        // msOld.DumpAllObjectsSince();
    }
    catch (std::exception& e)
    {
        std::cerr << "Unexpected ERROR: " << e.what() << std::endl;
        exit(EXIT_FAILURE);
    }
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CCheap3DApp object

CCheap3DApp theApp;


/////////////////////////////////////////////////////////////////////////////
// CCheap3DApp cleanup

int CCheap3DApp::ExitInstance()
{
    int retVal;
    try
    {
        retVal = CWinApp::ExitInstance();

    }

    catch (std::exception& e)
    {
        std::cerr << "Unexpected ERROR: " << e.what() << std::endl;
        exit(EXIT_FAILURE);
    }

    return retVal;

}

/////////////////////////////////////////////////////////////////////////////
// CCheap3DApp initialization

BOOL CCheap3DApp::InitInstance()
{
    // open the logFile very first thing, prior to
    // instantiation of other objects...
    extern ofstream logFile;
//    ====================================================
//    Get the application directory with standard string
//    ====================================================
    char szAppPath[_MAX_PATH] = "";
    char szAppDirectory[_MAX_PATH] = "";

    ::GetModuleFileName(0, szAppPath, sizeof(szAppPath) - 1);

    // Extract directory
    strncpy_s(appDirName, szAppPath, strrchr(szAppPath, '\\') - szAppPath);
    appDirName[strlen(appDirName)] = '\0';

    char logFileName[_MAX_PATH];

    strcpy(logFileName, appDirName);
    strcat(logFileName, "\\LFI_Player_log.txt\0");

    logFile.open(logFileName, ios::out);

    AfxEnableControlContainer();

    // Standard initialization
    // If you are not using these features and wish to reduce the size
    //  of your final executable, you should remove from the following
    //  the specific initialization routines you do not need.

#ifdef _AFXDLL
    Enable3dControls();			// Call this when using MFC in a shared DLL
#else
    // following is no longer needed...
    // Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

    // Change the registry key under which our settings are stored.
    // You should modify this string to be something appropriate
    // such as the name of your company or organization.
    SetRegistryKey(_T("Lazerus Laser Systems"));

    LoadStdProfileSettings();  // Load standard INI file options (including MRU)

    // Register the application's document templates.  Document templates
    //  serve as the connection between documents, frame windows and views.

    CSingleDocTemplate* pDocTemplate;
    pDocTemplate = new CSingleDocTemplate(
        IDR_MAINFRAME,
        RUNTIME_CLASS(CCheap3DDoc),
        RUNTIME_CLASS(CMainFrame),       // main SDI frame window
        RUNTIME_CLASS(CCheap3DView));

    AddDocTemplate(pDocTemplate);

    // Parse command line for standard shell commands, DDE, file open
    CCommandLine cmdInfo;
    ParseCommandLine(cmdInfo);
    appCmdLineInfo = cmdInfo.cmdLineInfo;

    // Dispatch commands specified on the command line
    if (!ProcessShellCommand(cmdInfo))
        return FALSE;

    CRect rect;

//    m_pMainWnd->ShowWindow(SW_SHOWMAXIMIZED);  

    rect.SetRect(0,0,0,0);
/*    rect.SetRect(MAIN_WINDOW_LEFT_DEFAULT,
                 MAIN_WINDOW_TOP_DEFAULT,
                 MAIN_WINDOW_RIGHT_DEFAULT,
                 MAIN_WINDOW_BOTTOM_DEFAULT); */

    m_pMainWnd->MoveWindow(&rect);

    // The one and only window has been initialized, so show and update it.
    m_pMainWnd->ShowWindow(SW_SHOW);
    m_pMainWnd->UpdateWindow();

    /*  // Following code shows how to get a pointer to the CCheap3DView
    // dialog window...

    POSITION pos = GetFirstDocTemplatePosition();
    CDocTemplate* pDocTemplate2 = GetNextDocTemplate(pos);

    // Get a pointer to the document
    pos = pDocTemplate2->GetFirstDocPosition();
    CDocument* pDoc = pDocTemplate->GetNextDoc(pos);

    // Get a pointer to the view
    pos = pDoc->GetFirstViewPosition();
    CCheap3DView* viewPtr = (CCheap3DView*)(pDoc->GetNextView(pos));

    viewPtr->mainWindowPtr = m_pMainWnd; */

    if (!logFile)
    {
        m_pMainWnd->MessageBox("Unable to open logfile for write.");
        return FALSE;
    }

//    ========================================
//    With CString
//    ========================================
//    char szAppPath[MAX_PATH] = "";
//    CString strAppDirectory;
//
//    ::GetModuleFileName(0, szAppPath, sizeof(szAppPath) - 1);
//
//    // Extract directory
//    strAppDirectory = szAppPath;
//    strAppDirectory = strAppDirectory.Left(strAppDirectory.ReverseFind('\\'));

//    if( _getcwd( appDirName, _MAX_PATH ) == NULL )
//	{
//		m_pMainWnd->MessageBox("Unable to get app directory name.");
//        return FALSE;
//	}

#ifdef BASIC_LOG_INFO
    logFile << "Starting program LFI_Player from directory\n" 
            << appDirName << endl;
#endif

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
    CAboutDlg();

// Dialog Data
    //{{AFX_DATA(CAboutDlg)
    enum { IDD = IDD_ABOUTBOX };
    //}}AFX_DATA

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAboutDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    //{{AFX_MSG(CAboutDlg)
        // No message handlers
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
    //{{AFX_DATA_INIT(CAboutDlg)
    //}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAboutDlg)
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
    //{{AFX_MSG_MAP(CAboutDlg)
        // No message handlers
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void CCheap3DApp::OnAppAbout()
{
    CAboutDlg aboutDlg;
    aboutDlg.DoModal();
}

// Following no longer necessary, but keep the source to show how
// to call a function in the main window.
//
// void CCheap3DApp::OnOpenIldaFile() 
// {
//	
//	// Get a pointer to the document template
//	POSITION pos = GetFirstDocTemplatePosition();
//	CDocTemplate* pDocTemplate = GetNextDocTemplate(pos);
//
//	// Get a pointer to the document
//	pos = pDocTemplate->GetFirstDocPosition();
//	CDocument* pDoc = pDocTemplate->GetNextDoc(pos);
//
//	// Get a pointer to the view
//	pos = pDoc->GetFirstViewPosition();
//	CCheap3DView* viewPtr = (CCheap3DView*)(pDoc->GetNextView(pos));
//
//    viewPtr->OpenIldaFile();
//	// End my code
//		
// }
