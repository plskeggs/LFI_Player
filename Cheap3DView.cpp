//
// *********************************************************
// *                                                       *
// * Copyright 1998-2022, Lazerus Laser Systems            *
// * Author: Michael G. Svob                               *
// *                                                       *
// * File Name: Cheap3DView.cpp                            *
// * Description: Implementation of the CCheap3DView       *
// * class.  Right or wrong (probably more wrong), the     *
// * Cheap3DView object is the "hub of the wheel" around   *
// * which all of the spokes extend.                       *
// *                                                       *
// * NOTE: This file was generated by MS Visual Studio,    *
// *       and modified by the author as necessary for     *
// *       the LFI Player application.
// *                                                       *
// * This code is distributed under the GNU Public License *
// * which can be found at...                              *
// *                                                       *
// * http://www.gnu.org/licenses/gpl.txt                   *
// *                                                       *
// *********************************************************
//

#include <iostream>
#include <fstream>
#include <direct.h>
#include <time.h>

#include "stdafx.h"
#include "Cheap3D.h"

#include "Cheap3DDoc.h"
#include "Cheap3DView.h"
#include "SelectPort.h"
#include "Preferences.h"
#include "LiveControl.h"
#include "FontList.h"
#include "TextScroll.h"
#include "CommandLine.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

using namespace std; 

extern ofstream logFile;
extern char appDirName[_MAX_PATH];
extern CommandLineInfo_T  appCmdLineInfo;

#include "Cheap3DViewPalette.cpp"
#include "Cheap3DViewLaser.cpp"
#include "Cheap3DViewCommands.cpp"
#include "Cheap3DViewToolbar.cpp"
#include "Cheap3DViewControl.cpp"

// char IniFileHeaderString[] = "LFI_Player Configuration Data File, Version %s\r\n" VERSION_NUMBER;
char IniFileHeaderString[] = "LFI_Player Configuration Data File, Version 1.2.3\r\n";
char MinIniFileHeaderString[] = "LFI_Player Configuration Data File, Version 1.2.1\r\n";

// msvob 5/5/2022: Investigate how you could use the following to deal with the Version number separate from the rest of the string...
// char* string;
// if (0 > asprintf(&string, "Formatting a number: %d\n", 42)) return error;
// log_out(string);
// free(string);
                                                                                                                                    
////////////////////////////////////////////////////////////////////
//
// CCheap3DView
//
////////////////////////////////////////////////////////////////////
IMPLEMENT_DYNCREATE(CCheap3DView, CFormView)

////////////////////////////////////////////////////////////////////
//
// CCheap3DView Message Map
//
////////////////////////////////////////////////////////////////////
BEGIN_MESSAGE_MAP(CCheap3DView, CFormView)
    //{{AFX_MSG_MAP(CCheap3DView)
    ON_WM_TIMER()
    ON_COMMAND(ID_OPEN_CTS_FILE, OnOpenCtsFile)
    ON_COMMAND(ID_OPEN_ILDA_FILE, OnOpenIldaFile)
    ON_COMMAND(ID_FILE_CLOSETRACKLIST, OnFileClosetracklist)
    ON_COMMAND(ID_DISPLAY_PLAY, OnDisplayPlay)
    ON_COMMAND(ID_DISPLAY_PAUSE, OnDisplayPause)
    ON_COMMAND(ID_DISPLAY_ROTATE_FROM_PLUS_X, OnDisplayRotatePlusX)
    ON_COMMAND(ID_DISPLAY_ROTATE_FROM_MINUS_X, OnDisplayRotateMinusX)
    ON_COMMAND(ID_DISPLAY_ROTATE_FROM_PLUS_Y, OnDisplayRotatePlusY)
    ON_COMMAND(ID_DISPLAY_ROTATE_FROM_MINUS_Y, OnDisplayRotateMinusY)
    ON_COMMAND(ID_DISPLAY_ROTATE_FROM_PLUS_Z, OnDisplayRotatePlusZ)
    ON_COMMAND(ID_DISPLAY_ROTATE_FROM_MINUS_Z, OnDisplayRotateMinusZ)
    ON_COMMAND(ID_DISPLAY_ROTATE_BOTH_PLUS_X, OnDisplayRotateBothPlusX)
    ON_COMMAND(ID_DISPLAY_ROTATE_BOTH_MINUS_X, OnDisplayRotateBothMinusX)
    ON_COMMAND(ID_DISPLAY_ROTATE_BOTH_PLUS_Y, OnDisplayRotateBothPlusY)
    ON_COMMAND(ID_DISPLAY_ROTATE_BOTH_MINUS_Y, OnDisplayRotateBothMinusY)
    ON_COMMAND(ID_DISPLAY_ROTATE_BOTH_PLUS_Z, OnDisplayRotateBothPlusZ)
    ON_COMMAND(ID_DISPLAY_ROTATE_BOTH_MINUS_Z, OnDisplayRotateBothMinusZ)
    ON_BN_CLICKED(IDC_CHECK_ARM1, OnCheckArm1)
    ON_BN_CLICKED(IDC_CHECK_ARM2, OnCheckArm2)
    ON_BN_CLICKED(IDC_CHECK_ARM3, OnCheckArm3)
    ON_BN_CLICKED(IDC_CHECK_ARM4, OnCheckArm4)
    ON_BN_CLICKED(IDC_CHECK_DISPLAY1, OnCheckDisplay1)
    ON_BN_CLICKED(IDC_CHECK_DISPLAY2, OnCheckDisplay2)
    ON_BN_CLICKED(IDC_CHECK_DISPLAY3, OnCheckDisplay3)
    ON_BN_CLICKED(IDC_CHECK_DISPLAY4, OnCheckDisplay4)
    ON_BN_CLICKED(IDC_RADIO_FOCUS1, OnRadioFocus1)
    ON_BN_CLICKED(IDC_RADIO_FOCUS2, OnRadioFocus2)
    ON_BN_CLICKED(IDC_RADIO_FOCUS3, OnRadioFocus3)
    ON_BN_CLICKED(IDC_RADIO_FOCUS4, OnRadioFocus4)
    ON_COMMAND(ID_DISPLAY_ZOOM_IN, OnDisplayZoomIn)
    ON_COMMAND(ID_DISPLAY_ZOOM_OUT, OnDisplayZoomOut)
    ON_COMMAND(ID_DISPLAY_INCREASE_DELAY, OnDisplayIncreaseDelay)
    ON_COMMAND(ID_DISPLAY_DECREASE_DELAY, OnDisplayDecreaseDelay)
    ON_COMMAND(ID_DISPLAY_INCREASE_FOCUS_REPEAT, OnDisplayIncreaseFocusRepeat)
    ON_COMMAND(ID_DISPLAY_DECREASE_FOCUS_REPEAT, OnDisplayDecreaseFocusRepeat)
    ON_COMMAND(ID_DISPLAY_INCREASE_BLANKING_DELAY, OnDisplayIncreaseBlankingDelay)
    ON_COMMAND(ID_DISPLAY_DECREASE_BLANKING_DELAY, OnDisplayDecreaseBlankingDelay)
    ON_COMMAND(ID_DISPLAY_INCREASE_GLOBAL_DELAY, OnDisplayIncreaseGlobalDelay)
    ON_COMMAND(ID_DISPLAY_DECREASE_GLOBAL_DELAY, OnDisplayDecreaseGlobalDelay)
    ON_COMMAND(ID_DISPLAY_INCREASE_TRACK_SCALE, OnDisplayIncreaseTrackScale)
    ON_COMMAND(ID_DISPLAY_DECREASE_TRACK_SCALE, OnDisplayDecreaseTrackScale)
    ON_COMMAND(ID_DISPLAY_INCREASE_LASER_SCALE, OnDisplayIncreaseLaserScale)
    ON_COMMAND(ID_DISPLAY_DECREASE_LASER_SCALE, OnDisplayDecreaseLaserScale)
    ON_COMMAND(ID_DISPLAY_INCREASE_MOVE_INCREMENT, OnDisplayIncreaseMoveIncrement)
    ON_COMMAND(ID_DISPLAY_DECREASE_MOVE_INCREMENT, OnDisplayDecreaseMoveIncrement)
    ON_COMMAND(ID_DISPLAY_INCREASE_ZOOM_INCREMENT, OnDisplayIncreaseZoomIncrement)
    ON_COMMAND(ID_DISPLAY_DECREASE_ZOOM_INCREMENT, OnDisplayDecreaseZoomIncrement)
    ON_COMMAND(ID_DISPLAY_INCREASE_ROTATE_INCREMENT, OnDisplayIncreaseRotateIncrement)
    ON_COMMAND(ID_DISPLAY_DECREASE_ROTATE_INCREMENT, OnDisplayDecreaseRotateIncrement)
    ON_WM_HSCROLL()
#ifdef LEGACY_OUTPUT
    ON_COMMAND(ID_OPTIONS_SELECTPORT, OnOptionsSelectport)
#endif
    ON_COMMAND(ID_BUTTON_RESET, OnButtonReset)
    ON_BN_CLICKED(IDC_CHECK_POINTS_ONLY, OnCheckPointsOnly)
    ON_COMMAND(ID_OPEN_CLV_FILE, OnOpenClvFile)
    ON_COMMAND(IDC_LIVE_BUTTON1, OnLiveButton1)
    ON_COMMAND(IDC_LIVE_BUTTON2, OnLiveButton2)
    ON_COMMAND(IDC_LIVE_BUTTON3, OnLiveButton3)
    ON_COMMAND(IDC_LIVE_BUTTON4, OnLiveButton4)
    ON_COMMAND(IDC_LIVE_BUTTON5, OnLiveButton5)
    ON_COMMAND(IDC_LIVE_BUTTON6, OnLiveButton6)
    ON_COMMAND(IDC_LIVE_BUTTON7, OnLiveButton7)
    ON_COMMAND(IDC_LIVE_BUTTON8, OnLiveButton8)
    ON_COMMAND(IDC_LIVE_BUTTON9, OnLiveButton9)
    ON_COMMAND(IDC_LIVE_BUTTON10, OnLiveButton10)
    ON_COMMAND(IDC_LIVE_BUTTON11, OnLiveButton11)
    ON_COMMAND(IDC_LIVE_BUTTON12, OnLiveButton12)
    ON_COMMAND(IDC_LIVE_BUTTON13, OnLiveButton13)
    ON_COMMAND(IDC_LIVE_BUTTON14, OnLiveButton14)
    ON_COMMAND(IDC_LIVE_BUTTON15, OnLiveButton15)
    ON_COMMAND(IDC_LIVE_BUTTON16, OnLiveButton16)
    ON_COMMAND(IDC_LIVE_BUTTON17, OnLiveButton17)
    ON_COMMAND(IDC_LIVE_BUTTON18, OnLiveButton18)
    ON_COMMAND(IDC_LIVE_BUTTON19, OnLiveButton19)
    ON_COMMAND(IDC_LIVE_BUTTON20, OnLiveButton20)
    ON_COMMAND(IDC_LIVE_BUTTON21, OnLiveButton21)
    ON_COMMAND(IDC_LIVE_BUTTON22, OnLiveButton22)
    ON_COMMAND(IDC_LIVE_BUTTON23, OnLiveButton23)
    ON_COMMAND(IDC_LIVE_BUTTON24, OnLiveButton24)
    ON_COMMAND(IDC_LIVE_BUTTON25, OnLiveButton25)
    ON_COMMAND(IDC_LIVE_BUTTON26, OnLiveButton26)
    ON_COMMAND(IDC_LIVE_BUTTON27, OnLiveButton27)
    ON_COMMAND(IDC_LIVE_BUTTON28, OnLiveButton28)
    ON_COMMAND(IDC_LIVE_BUTTON29, OnLiveButton29)
    ON_COMMAND(IDC_LIVE_BUTTON30, OnLiveButton30)
    ON_COMMAND(IDC_LIVE_BUTTON31, OnLiveButton31)
    ON_COMMAND(IDC_LIVE_BUTTON32, OnLiveButton32)
    ON_COMMAND(IDC_LIVE_BUTTON33, OnLiveButton33)
    ON_COMMAND(IDC_LIVE_BUTTON34, OnLiveButton34)
    ON_COMMAND(IDC_LIVE_BUTTON35, OnLiveButton35)
    ON_COMMAND(IDC_LIVE_BUTTON36, OnLiveButton36)
    ON_COMMAND(IDC_LIVE_BUTTON37, OnLiveButton37)
    ON_COMMAND(IDC_LIVE_BUTTON38, OnLiveButton38)
    ON_COMMAND(IDC_LIVE_BUTTON39, OnLiveButton39)
    ON_COMMAND(IDC_LIVE_BUTTON40, OnLiveButton40)
    ON_COMMAND(IDC_LIVE_BUTTON41, OnLiveButton41)
    ON_COMMAND(IDC_LIVE_BUTTON42, OnLiveButton42)
    ON_COMMAND(IDC_LIVE_BUTTON43, OnLiveButton43)
    ON_COMMAND(IDC_LIVE_BUTTON44, OnLiveButton44)
    ON_COMMAND(IDC_LIVE_BUTTON45, OnLiveButton45)
    ON_COMMAND(IDC_LIVE_BUTTON46, OnLiveButton46)
    ON_COMMAND(IDC_LIVE_BUTTON47, OnLiveButton47)
    ON_COMMAND(IDC_LIVE_BUTTON48, OnLiveButton48)
    ON_COMMAND(ID_LIVE_PAGE_NEXT, OnLivePageNext)
    ON_COMMAND(ID_LIVE_PAGE_PREV, OnLivePagePrevious)
    ON_COMMAND(ID_MOVE_BOTH_PLUS_X, OnMoveBothPlusX)
    ON_COMMAND(ID_MOVE_BOTH_MINUS_X, OnMoveBothMinusX)
    ON_COMMAND(ID_MOVE_BOTH_PLUS_Y, OnMoveBothPlusY)
    ON_COMMAND(ID_MOVE_BOTH_MINUS_Y, OnMoveBothMinusY)
    ON_COMMAND(ID_MOVE_BOTH_PLUS_Z, OnMoveBothPlusZ)
    ON_COMMAND(ID_MOVE_BOTH_MINUS_Z, OnMoveBothMinusZ)
    ON_COMMAND(ID_MOVE_FROM_PLUS_X, OnMoveFromPlusX)
    ON_COMMAND(ID_MOVE_FROM_MINUS_X, OnMoveFromMinusX)
    ON_COMMAND(ID_MOVE_FROM_PLUS_Y, OnMoveFromPlusY)
    ON_COMMAND(ID_MOVE_FROM_MINUS_Y, OnMoveFromMinusY)
    ON_COMMAND(ID_MOVE_FROM_PLUS_Z, OnMoveFromPlusZ)
    ON_COMMAND(ID_MOVE_FROM_MINUS_Z, OnMoveFromMinusZ)
    ON_COMMAND(ID_MOVE_AT_PLUS_X, OnMoveAtPlusX)
    ON_COMMAND(ID_MOVE_AT_MINUS_X, OnMoveAtMinusX)
    ON_COMMAND(ID_MOVE_AT_PLUS_Y, OnMoveAtPlusY)
    ON_COMMAND(ID_MOVE_AT_MINUS_Y, OnMoveAtMinusY)
    ON_COMMAND(ID_MOVE_AT_PLUS_Z, OnMoveAtPlusZ)
    ON_COMMAND(ID_MOVE_AT_MINUS_Z, OnMoveAtMinusZ)
    ON_COMMAND(ID_MOVE_FORWARD, OnMoveForward)
    ON_COMMAND(ID_MOVE_BACKWARD, OnMoveBackward)
    ON_BN_CLICKED(IDC_CHECK_EFFECT1, OnCheckEffect1)
    ON_BN_CLICKED(IDC_CHECK_EFFECT2, OnCheckEffect2)
    ON_BN_CLICKED(IDC_CHECK_EFFECT3, OnCheckEffect3)
    ON_BN_CLICKED(IDC_CHECK_EFFECT4, OnCheckEffect4)
    ON_BN_CLICKED(IDC_CHECK_ROT_ABT0_1, OnCheckRotAbt01)
    ON_BN_CLICKED(IDC_CHECK_ROT_ABT0_2, OnCheckRotAbt02)
    ON_BN_CLICKED(IDC_CHECK_ROT_ABT0_3, OnCheckRotAbt03)
    ON_BN_CLICKED(IDC_CHECK_ROT_ABT0_4, OnCheckRotAbt04)
    ON_WM_PAINT()
    ON_BN_CLICKED(IDC_CHECK_DISPLAY_COORDINATES, OnCheckDisplayCoordinates)
    ON_COMMAND(ID_OPEN_ABS_FILE, OnOpenAbsFile)
    ON_COMMAND(ID_OPTIONS_PREFERENCES, OnOptionsPreferences)
    ON_COMMAND(ID_DISPLAY_REWIND, OnDisplayRewind)
    ON_BN_CLICKED(IDC_RADIO_PANGOLIN, OnRadioPangolin)
    ON_BN_CLICKED(IDC_RADIO_LASER_ILLUSIONS, OnRadioLaserIllusions)
    ON_BN_CLICKED(IDC_RADIO_X29, OnRadioX29)
    ON_COMMAND(ID_DISPLAY_RECORD, OnDisplayRecord)
    ON_BN_CLICKED(IDC_CHECK_REVERSE, OnCheckReverse)
    ON_BN_CLICKED(IDC_RADIO_ILDA, OnRadioIlda)
    ON_WM_LBUTTONDOWN()
    ON_WM_LBUTTONUP()
    ON_WM_MOUSEMOVE()
    ON_BN_CLICKED(IDC_CHECK_BEAMVIEW, OnCheckBeamview)
    ON_COMMAND(ID_OPEN_TXT_FILE, OnOpenTxtFile)
    //}}AFX_MSG_MAP
#ifdef USE_SERIAL_COM
    ON_WM_SERIAL(OnSerialMsg)
#endif

END_MESSAGE_MAP()

////////////////////////////////////////////////////////////////////
//
// CCheap3DView::CCheap3DView()
//
////////////////////////////////////////////////////////////////////
CCheap3DView::CCheap3DView()
    : CFormView(CCheap3DView::IDD),
//	gemLaserPtr(0),
    trackList(),
    trackPtr(0),
    framePtr(0),
    clientDCPtr(0),
    ctsFilePtr(0),
    outFile(0),
    numPointsDisplayed(0),
    liveDialog(0),
    abstractDialog(0),
    preferencesDialog(0),
    trackNumber(0),
    scriptActive(M_FALSE),
    invertBitmap(0),
    invertBlanking(M_FALSE),
    blankingShift(0),
    numberOfLoops(0),
    loopCounter(0),
    commandInProgress(M_FALSE),
    colorMode(DisplayColorMode::COLOR_NORMAL),
    masterRed(1.0),
    masterGreen(1.0),
    masterBlue(1.0),
    ttlThresholdRed(0.5),
    ttlThresholdGreen(0.5),
    ttlThresholdBlue(0.5),
    displayTimerValue(100),
    m_BlankingDelay(50),
    fadeInFrames(15),
    fadeOutFrames(15),
    colorIntensity(100),
    globalFrameRepeat(0),
    dragObjectPtr(0),
    dragInertia(50),
    dragSpeed(1),
    parentFramePtr(0),
    defaultGlobalDelay(0),
    defaultLaserScale(50),
    defaultVerticalScale(100),
    currentFrameNumber(0),
    currentNumberPoints(0),
    frameNumPosArray(0),
    beamMode(NORMAL),
    beamOriginX1(0.5),
    beamOriginY1(0.3),
    beamOriginX2(0.5),
    beamOriginY2(0.3),
    beamHeight1(0.32),
    beamHeight2(0.32),
    beamOn1(TRUE),
    beamOn2(FALSE),
    beamInvertX1(FALSE),
    beamInvertX2(TRUE),
    beamYagView(FALSE),
    leftPreviewEdgePixels(267),
    initMainWindow(TRUE),
    firstTime2(TRUE),
    useSerialPort(M_FALSE)
{
#ifdef CHEAP3DVIEW_LOG_INFO
    logFile << "Entering CCheap3DView::CCheap3DView()" << endl;
#endif

    //{{AFX_DATA_INIT(CCheap3DView)
    m_DisplayTrack1 = FALSE;
    m_DisplayTrack2 = FALSE;
    m_DisplayTrack3 = FALSE;
    m_DisplayTrack4 = FALSE;
    m_ArmTrack1 = FALSE;
    m_ArmTrack2 = FALSE;
    m_ArmTrack3 = FALSE;
    m_ArmTrack4 = FALSE;
    m_FocusTrackDelay = 0;
    m_BlankingDelay = 0;
    m_PointsOnly = FALSE;
    m_TrackFocusButton = 0;
    m_EffectTrack1 = FALSE;
    m_EffectTrack2 = FALSE;
    m_EffectTrack3 = FALSE;
    m_EffectTrack4 = FALSE;
    m_RotateAbout0_1 = FALSE;
    m_RotateAbout0_2 = FALSE;
    m_RotateAbout0_3 = FALSE;
    m_RotateAbout0_4 = FALSE;
    m_TrackScale = 0;
    m_DisplayCoordinates = FALSE;
    m_FromPointX = 0.0f;
    m_FromPointY = 0.0f;
    m_FromPointZ = 0.0f;
    m_AtPointX = 0.0f;
    m_AtPointY = 0.0f;
    m_AtPointZ = 0.0f;
    m_ILDA_Palette_Button = 0;
    m_Reverse = FALSE;
    m_TrackBlueBalance = 0;
    m_TrackGreenBalance = 0;
    m_TrackRedBalance = 0;
    m_TrackCameraAngle = 0;
    m_DisplayBeamView = FALSE;
    m_FocusTrackRepeat = 0;
    //}}AFX_DATA_INIT
    // TODO: add construction code here
    displayParams.delayValue = 1000;
    displayParams.displayMode = DISPLAY_OFF;
    displayParams.colorFactor = 1.0;
    displayParams.redLevel    = 1.0;
    displayParams.greenLevel  = 1.0;
    displayParams.blueLevel   = 1.0;
    displayParams.repeatCount = 0;
    displayParams.frameRepeat = 0;
    displayParams.startFrameNumber = -1;

    int i;

    for (i=0 ; i<MAX_TRACKS ; ++i)
        outputDeviceArray[i] = 0;

    for (i=0 ; i<MAX_BASENAME_SIZE ; ++i)
        contentDirectoryName[i] = 0;

}

////////////////////////////////////////////////////////////////////
//
// CCheap3DView::~CCheap3DView()
//
////////////////////////////////////////////////////////////////////
CCheap3DView::~CCheap3DView()
{
#ifdef CHEAP3DVIEW_LOG_INFO
    logFile << "Entering CCheap3DView::~CCheap3DView()" << endl;
#endif

// msvob 4/9/2022: Why is this commented out?
//    OnFileClosetracklist();

    if (_chdir(appDirName) == -1)
    {
#ifdef CHEAP3DVIEW_LOG_ERROR
           logFile << "~CCheap3DView(): Unable to return to root directory." << endl;
#endif
    }
    else
    {
        FILE*    iniOutFile;
        fopen_s(&iniOutFile, "LFI_Player.ini", "wb");

        CWnd* tempMainWnd = AfxGetMainWnd();

        if (firstTime2 == FALSE  &&
            tempMainWnd)
        {
            tempMainWnd->GetWindowRect(&mainWindowRect);
        }

        int tempComportIndex     = comStringToIndex(strComPort);
        int tempBaudrateIndex    = baudrateToIndex(serialPort.GetBaudrate());
        int tempDatabitsIndex    = databitsToIndex(serialPort.GetDataBits());
        int tempParityIndex      = parityToIndex(serialPort.GetParity());
        int tempStopbitsIndex    = stopbitsToIndex(serialPort.GetStopBits());
        int tempHandshakeIndex   = handshakeToIndex(serialPort.GetHandshaking());


#ifdef BASIC_LOG_INFO
        logFile << "Writing the following values to LFI_Player.ini:" << "\n"
                << "          BasePort: 0x" << hex << gemLaserPtr->GetBasePort() << dec << "\n"
                << "      DisplayLaser: " << (M_UINT16)displayLaser << "\n"
                << "     DisplayScreen: " << (M_UINT16)displayScreen << "\n"
                << "       FlickerFree: " << (M_UINT16)flickerFree << "\n"
                << "    InvertBlanking: " << invertBlanking << "\n"
                << "      ScriptRepeat: " << (M_UINT16)scriptRepeat << "\n"
                << "   Blank/Clip View: " << (M_UINT16)blankClipView << "\n"
                << "       GlobalDelay: " << defaultGlobalDelay << "\n"
                << "        LaserScale: " << defaultLaserScale << "\n"
                << "     VerticalScale: " << defaultVerticalScale << "\n"
                << "     BlankingShift: " << blankingShift << "\n"
                << "      DisplayTimer: " << displayTimerValue << "\n"
                << "         ColorMode: " << (M_UINT16)colorMode << "\n"
                << "         MasterRed: " << (M_UINT16)(masterRed*100.0) << "\n"
                << "       MasterGreen: " << (M_UINT16)(masterGreen*100.0) << "\n"
                << "        MasterBlue: " << (M_UINT16)(masterBlue*100.0) << "\n"
                << "   TTLThresholdRed: " << (M_UINT16)(ttlThresholdRed*100.0) << "\n"
                << " TTLThresholdGreen: " << (M_UINT16)(ttlThresholdGreen*100.0) << "\n"
                << "  TTLThresholdBlue: " << (M_UINT16)(ttlThresholdBlue*100.0) << "\n"
                << "      InvertBitmap: " << invertBitmap << "\n"
                << "      Frames2Write: " << numFramesToWrite << "\n"
                << "     RecordPalette: " << (M_UINT16)recordPaletteType << "\n"
                << "        RecordView: " << (M_UINT16)recordViewType << "\n"
                << "      FadeInFrames: " << fadeInFrames << "\n"
                << "     FadeOutFrames: " << fadeOutFrames << "\n"
                << " GlobalFrameRepeat: " << globalFrameRepeat << "\n"
                << "    ColorIntensity: " << colorIntensity << "\n"
                << "     MoveIncrement: " << moveIncrement << "\n"
                << "   RotateIncrement: " << rotateIncrement << "\n"
                << "     ZoomIncrement: " << zoomIncrement << "\n"
                << "        Drag Speed: " << dragSpeed << "\n"
                << "      Drag Inertia: " << dragInertia << "\n"
                << " Points Per Second: " << outputPPS << "\n"
                << "    Beam X1 Origin: " << beamOriginX1 << "\n"
                << "    Beam Y1 Origin: " << beamOriginY1 << "\n"
                << "    Beam X2 Origin: " << beamOriginX2 << "\n"
                << "    Beam Y2 Origin: " << beamOriginY2 << "\n"
                << "     Beam 1 Height: " << beamHeight1 << "\n"
                << "     Beam 2 Height: " << beamHeight2 << "\n"
                << "         Beam 1 On: " << (M_UINT16)beamOn1 << "\n"
                << "         Beam 2 On: " << (M_UINT16)beamOn2 << "\n"
                << "   Beam 1 Invert X: " << (M_UINT16)beamInvertX1 << "\n"
                << "   Beam 2 Invert X: " << (M_UINT16)beamInvertX2 << "\n"
                << "     Beam YAG View: " << (M_UINT16)beamYagView << "\n"
                << "         Beam Mode: " << (int)beamMode << "\n"
                << " Content Directory: " << &contentDirectoryName[0] << "\n"
                << "  Main Window Left: " << mainWindowRect.left << "\n"
                << "   Main Window Top: " << mainWindowRect.top << "\n"
                << " Main Window Right: " << mainWindowRect.right << "\n"
                << "Main Window Bottom: " << mainWindowRect.bottom << "\n"
                << " Left Preview Edge: " << leftPreviewEdgePixels << "\n"
                << "    COM Port Index: " << tempComportIndex << "\n"
                << "   Baud Rate Index: " << tempBaudrateIndex << "\n"
                << "   Data Bits Index: " << tempDatabitsIndex << "\n"
                << "      Parity Index: " << tempParityIndex << "\n"
                << "   Stop Bits Index: " << tempStopbitsIndex << "\n"
                << "  Hand Shake Index: " << tempHandshakeIndex << "\n"
                << "   Use Serial Port: " << useSerialPort << endl;

#endif

        if(strcmp(contentDirectoryName,"") == 0)
        {
            strcpy(contentDirectoryName, "___\\0");

#ifdef BASIC_LOG_INFO
            logFile << "Content directory name is empty, storing placeholder..." << endl;
#endif
        }

        if (iniOutFile)
        {
            BOOL writeSuccess = TRUE;

            if (!fprintf(iniOutFile, IniFileHeaderString))
            {
                writeSuccess = FALSE;
            }

            if (!fprintf(iniOutFile,"PORT_BASE_ADDRESS=%d\r\n", gemLaserPtr->GetBasePort()))
            {
                writeSuccess = FALSE;
            }

            if (!fprintf(iniOutFile,"DISPLAY_LASER=%d\r\n", (M_UINT16)displayLaser))
            {
                writeSuccess = FALSE;
            }

            if (!fprintf(iniOutFile,"DISPLAY_SCREEN=%d\r\n", (M_UINT16)displayScreen))
            {
                writeSuccess = FALSE;
            }

            if (!fprintf(iniOutFile,"FLICKER_FREE=%d\r\n", (M_UINT16)flickerFree))
            {
                writeSuccess = FALSE;
            }

            if (!fprintf(iniOutFile,"INVERT_BLANKING=%d\r\n", invertBlanking))
            {
                writeSuccess = FALSE;
            }

            if (!fprintf(iniOutFile,"SCRIPT_REPEAT=%d\r\n", (M_UINT16)scriptRepeat))
            {
                writeSuccess = FALSE;
            }

            if (!fprintf(iniOutFile,"BLANK/CLIP_VIEW=%d\r\n", blankClipView))
            {
                writeSuccess = FALSE;
            }

            if (!fprintf(iniOutFile,"GLOBAL_DELAY=%ld\r\n", defaultGlobalDelay))
            {
                writeSuccess = FALSE;
            }

            if (!fprintf(iniOutFile,"LASER_SCALE=%ld\r\n", defaultLaserScale))
            {
                writeSuccess = FALSE;
            }

            if (!fprintf(iniOutFile,"VERTICAL_SCALE=%ld\r\n", defaultVerticalScale))
            {
                writeSuccess = FALSE;
            }

            if (!fprintf(iniOutFile,"BLANKING_SHIFT=%d\r\n", blankingShift))
            {
                writeSuccess = FALSE;
            }

            if (!fprintf(iniOutFile,"FRAME_DISPLAY_TIMER_VALUE=%d\r\n", displayTimerValue))
            {
                writeSuccess = FALSE;
            }

            if (!fprintf(iniOutFile,"COLOR_MODE=%d\r\n", (M_UINT16)colorMode))
            {
                writeSuccess = FALSE;
            }

            if (!fprintf(iniOutFile,"MASTER_RED_INTENSITY=%d\r\n", (M_UINT16)(masterRed*100.0)))
            {
                writeSuccess = FALSE;
            }

            if (!fprintf(iniOutFile,"MASTER_GREEN_INTENSITY=%d\r\n", (M_UINT16)(masterGreen*100.0)))
            {
                writeSuccess = FALSE;
            }

            if (!fprintf(iniOutFile,"MASTER_BLUE_INTENSITY=%d\r\n", (M_UINT16)(masterBlue*100.0)))
            {
                writeSuccess = FALSE;
            }

            if (!fprintf(iniOutFile,"TTL_THRESHOLD_RED=%d\r\n", (M_UINT16)(ttlThresholdRed*100.0)))
            {
                writeSuccess = FALSE;
            }

            if (!fprintf(iniOutFile,"TTL_THRESHOLD_GREEN=%d\r\n", (M_UINT16)(ttlThresholdGreen*100.0)))
            {
                writeSuccess = FALSE;
            }

            if (!fprintf(iniOutFile,"TTL_THRESHOLD_BLUE=%d\r\n", (M_UINT16)(ttlThresholdBlue*100.0)))
            {
                writeSuccess = FALSE;
            }

            if (!fprintf(iniOutFile,"DISPLAY_INVERT=%d\r\n", invertBitmap))
            {
                writeSuccess = FALSE;
            }

            if (!fprintf(iniOutFile,"RECORD_FRAMES_TO_WRITE=%d\r\n", numFramesToWrite))
            {
                writeSuccess = FALSE;
            }

            if (!fprintf(iniOutFile,"RECORD_PALETTE_TYPE=%d\r\n", (M_UINT16)recordPaletteType))
            {
                writeSuccess = FALSE;
            }

            if (!fprintf(iniOutFile,"RECORD_VIEW_TYPE=%d\r\n", (M_UINT16)recordViewType))
            {
                writeSuccess = FALSE;
            }

            if (!fprintf(iniOutFile,"NUMBER_FADE_IN_FRAMES=%d\r\n", fadeInFrames))
            {
                writeSuccess = FALSE;
            }

            if (!fprintf(iniOutFile,"NUMBER_FADE_OUT_FRAMES=%d\r\n", fadeOutFrames))
            {
                writeSuccess = FALSE;
            }

            if (!fprintf(iniOutFile,"GLOBAL_FRAME_REPEAT=%d\r\n", globalFrameRepeat))
            {
                writeSuccess = FALSE;
            }

            if (!fprintf(iniOutFile, "COLOR_INTENSITY=%d\r\n", colorIntensity))
            {
                writeSuccess = FALSE;
            }

            if (!fprintf(iniOutFile,"MOVE_INCREMENT=%d\r\n", moveIncrement))
            {
                writeSuccess = FALSE;
            }

            if (!fprintf(iniOutFile,"ROTATE_INCREMENT=%d\r\n", rotateIncrement))
            {
                writeSuccess = FALSE;
            }

            if (!fprintf(iniOutFile,"ZOOM_INCREMENT=%d\r\n", zoomIncrement))
            {
                writeSuccess = FALSE;
            }

            if (!fprintf(iniOutFile,"DRAG_SPEED=%d\r\n", dragSpeed))
            {
                writeSuccess = FALSE;
            }

            if (!fprintf(iniOutFile,"DRAG_INERTIA=%d\r\n", dragInertia))
            {
                writeSuccess = FALSE;
            }

            if (!fprintf(iniOutFile,"OUTPUT_PPS=%d\r\n", outputPPS))
            {
                writeSuccess = FALSE;
            }

            if (!fprintf(iniOutFile,"BEAM_ORIGIN_X1=%f\r\n", beamOriginX1))
            {
                writeSuccess = FALSE;
            }

            if (!fprintf(iniOutFile,"BEAM_ORIGIN_Y1=%f\r\n", beamOriginY1))
            {
                writeSuccess = FALSE;
            }

            if (!fprintf(iniOutFile,"BEAM_ORIGIN_X2=%f\r\n", beamOriginX2))
            {
                writeSuccess = FALSE;
            }

            if (!fprintf(iniOutFile,"BEAM_ORIGIN_Y2=%f\r\n", beamOriginY2))
            {
                writeSuccess = FALSE;
            }

            if (!fprintf(iniOutFile,"BEAM_HEIGHT_1=%f\r\n", beamHeight1))
            {
                writeSuccess = FALSE;
            }

            if (!fprintf(iniOutFile,"BEAM_HEIGHT_2=%f\r\n", beamHeight2))
            {
                writeSuccess = FALSE;
            }

            if (!fprintf(iniOutFile,"BEAM_ON_1=%d\r\n", beamOn1))
            {
                writeSuccess = FALSE;
            }

            if (!fprintf(iniOutFile,"BEAM_ON_2=%d\r\n", beamOn2))
            {
                writeSuccess = FALSE;
            }

            if (!fprintf(iniOutFile,"BEAM_INVERT_X1=%d\r\n", beamInvertX1))
            {
                writeSuccess = FALSE;
            }

            if (!fprintf(iniOutFile,"BEAM_INVERT_X2=%d\r\n", beamInvertX2))
            {
                writeSuccess = FALSE;
            }

            if (!fprintf(iniOutFile,"BEAM_YAG_VIEW=%d\r\n", (M_UINT16)beamYagView))
            {
                writeSuccess = FALSE;
            }

            if (!fprintf(iniOutFile,"BEAM_MODE=%d\r\n", (int)beamMode))
            {
                writeSuccess = FALSE;
            }

            if (!fprintf(iniOutFile,"CONTENT_DIRECTORY_NAME=%s\r\n", &contentDirectoryName[0]))
            {
                writeSuccess = FALSE;
            }

            if (!fprintf(iniOutFile,"MAIN_WINDOW_LEFT=%ld\r\n", mainWindowRect.left))
            {
                writeSuccess = FALSE;
            }

            if (!fprintf(iniOutFile,"MAIN_WINDOW_TOP=%ld\r\n", mainWindowRect.top))
            {
                writeSuccess = FALSE;
            }

            if (!fprintf(iniOutFile,"MAIN_WINDOW_RIGHT=%ld\r\n", mainWindowRect.right))
            {
                writeSuccess = FALSE;
            }

            if (!fprintf(iniOutFile,"MAIN_WINDOW_BOTTOM=%ld\r\n", mainWindowRect.bottom))
            {
                writeSuccess = FALSE;
            }

            if (!fprintf(iniOutFile,"LEFT_PREVIEW_EDGE=%d\r\n", leftPreviewEdgePixels))
            {
                writeSuccess = FALSE;
            }

            if (!fprintf(iniOutFile,"COM_PORT_INDEX=%d\r\n", tempComportIndex))
            {
                writeSuccess = FALSE;
            }

            if (!fprintf(iniOutFile,"BAUD_RATE_INDEX=%d\r\n", tempBaudrateIndex))
            {
                writeSuccess = FALSE;
            }

            if (!fprintf(iniOutFile,"DATA_BITS_INDEX=%d\r\n", tempDatabitsIndex))
            {
                writeSuccess = FALSE;
            }

            if (!fprintf(iniOutFile,"PARITY_INDEX=%d\r\n", tempParityIndex))
            {
                writeSuccess = FALSE;
            }

            if (!fprintf(iniOutFile,"STOP_BITS_INDEX=%d\r\n", tempStopbitsIndex))
            {
                writeSuccess = FALSE;
            }

            if (!fprintf(iniOutFile,"HAND_SHAKE_INDEX=%d\r\n", tempHandshakeIndex))
            {
                writeSuccess = FALSE;
            }

            if (!fprintf(iniOutFile,"USE_SERIAL_PORT=%d\r\n", useSerialPort))
            {
                writeSuccess = FALSE;
            }

            if (writeSuccess == FALSE)
            {
#ifdef CHEAP3DVIEW_LOG_ERROR
                logFile << "~CCheap3DView(): Unable to write LFI_Player.ini." << endl;
#endif
            }

            fclose(iniOutFile);
        }
        else
        {
#ifdef CHEAP3DVIEW_LOG_ERROR
            logFile << "~CCheap3DView(): Unable to open LFI_Player.ini for write." << endl;
#endif
        }

    } // else able to return to root directory to save .ini file

    for(M_UINT8 i=0 ; i<MAX_TRACKS ; ++i)
    {
        if(outputDeviceArray[i])
        {
            (outputDeviceArray[i])->DisplayOff(invertBlanking, colorMode);

 #ifdef RIYA_OUTPUT
            if((outputDeviceArray[i])->GetOutputDeviceType() == RIYA)
            { 
                ((Device_RIYA*)(outputDeviceArray[i]))->RiyaStop();
            }
#endif
            delete outputDeviceArray[i];
            outputDeviceArray[i] = 0;
        }
    }

    if (midiPtr)
    {
        delete midiPtr;
        midiPtr = 0;
    }
    
    if (clientDCPtr)
    {
        delete clientDCPtr;
        clientDCPtr = 0;
    }

    serialPort.Close();
    if (gemScreenPtr)
    {
        delete gemScreenPtr;
        gemScreenPtr = 0;
    }

#ifdef BASIC_LOG_INFO
    logFile << "Terminating program LFI_Player..." << endl;
#endif

    // logFile.close();
}

////////////////////////////////////////////////////////////////////
//
// CCheap3DView::DoDataExchange()
//
////////////////////////////////////////////////////////////////////
void CCheap3DView::DoDataExchange(CDataExchange* pDX)
{
    CFormView::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CCheap3DView)
    DDX_Control(pDX, IDC_SLIDER_TRACK_CAMERA_ANGLE, m_SliderTrackCameraAngle);
    DDX_Control(pDX, IDC_SLIDER_TRACK_RED_BAL, m_SliderTrackRedBalance);
    DDX_Control(pDX, IDC_SLIDER_TRACK_GREEN_BAL, m_SliderTrackGreenBalance);
    DDX_Control(pDX, IDC_SLIDER_TRACK_BLUE_BAL, m_SliderTrackBlueBalance);
    DDX_Control(pDX, IDC_SLIDER_TRACK_SCALE, m_SliderTrackScale);
    DDX_Control(pDX, IDC_SLIDER_BLANK_DELAY, m_SliderBlankDelay);
    DDX_Control(pDX, IDC_SLIDER_FOCUS_TRACK_RPT, m_SliderFocusTrackRepeat);
    DDX_Control(pDX, IDC_SLIDER_FOCUS_TRACK_DELAY, m_SliderFocusTrackDelay);
    DDX_Check(pDX, IDC_CHECK_DISPLAY1, m_DisplayTrack1);
    DDX_Check(pDX, IDC_CHECK_DISPLAY2, m_DisplayTrack2);
    DDX_Check(pDX, IDC_CHECK_DISPLAY3, m_DisplayTrack3);
    DDX_Check(pDX, IDC_CHECK_DISPLAY4, m_DisplayTrack4);
    DDX_Check(pDX, IDC_CHECK_ARM1, m_ArmTrack1);
    DDX_Check(pDX, IDC_CHECK_ARM2, m_ArmTrack2);
    DDX_Check(pDX, IDC_CHECK_ARM3, m_ArmTrack3);
    DDX_Check(pDX, IDC_CHECK_ARM4, m_ArmTrack4);
    DDX_Text(pDX, IDC_EDIT_FOCUS_TRACK_DELAY, m_FocusTrackDelay);
    DDX_Text(pDX, IDC_EDIT_BLANK_DELAY, m_BlankingDelay);
    DDX_Check(pDX, IDC_CHECK_POINTS_ONLY, m_PointsOnly);
    DDX_Radio(pDX, IDC_RADIO_FOCUS1, m_TrackFocusButton);
    DDX_Check(pDX, IDC_CHECK_EFFECT1, m_EffectTrack1);
    DDX_Check(pDX, IDC_CHECK_EFFECT2, m_EffectTrack2);
    DDX_Check(pDX, IDC_CHECK_EFFECT3, m_EffectTrack3);
    DDX_Check(pDX, IDC_CHECK_EFFECT4, m_EffectTrack4);
    DDX_Check(pDX, IDC_CHECK_ROT_ABT0_1, m_RotateAbout0_1);
    DDX_Check(pDX, IDC_CHECK_ROT_ABT0_2, m_RotateAbout0_2);
    DDX_Check(pDX, IDC_CHECK_ROT_ABT0_3, m_RotateAbout0_3);
    DDX_Check(pDX, IDC_CHECK_ROT_ABT0_4, m_RotateAbout0_4);
    DDX_Text(pDX, IDC_EDIT_TRACK_SCALE, m_TrackScale);
    DDX_Check(pDX, IDC_CHECK_DISPLAY_COORDINATES, m_DisplayCoordinates);
    DDX_Text(pDX, IDC_EDIT_FROM_POINT_X, m_FromPointX);
    DDX_Text(pDX, IDC_EDIT_FROM_POINT_Y, m_FromPointY);
    DDX_Text(pDX, IDC_EDIT_FROM_POINT_Z, m_FromPointZ);
    DDX_Text(pDX, IDC_EDIT_AT_POINT_X, m_AtPointX);
    DDX_Text(pDX, IDC_EDIT_AT_POINT_Y, m_AtPointY);
    DDX_Text(pDX, IDC_EDIT_AT_POINT_Z, m_AtPointZ);
    DDX_Radio(pDX, IDC_RADIO_PANGOLIN, m_ILDA_Palette_Button);
    DDX_Check(pDX, IDC_CHECK_REVERSE, m_Reverse);
    DDX_Text(pDX, IDC_EDIT_TRACK_BLUE_BAL, m_TrackBlueBalance);
    DDV_MinMaxUInt(pDX, m_TrackBlueBalance, 0, 100);
    DDX_Text(pDX, IDC_EDIT_TRACK_GREEN_BAL, m_TrackGreenBalance);
    DDV_MinMaxUInt(pDX, m_TrackGreenBalance, 0, 100);
    DDX_Text(pDX, IDC_EDIT_TRACK_RED_BAL, m_TrackRedBalance);
    DDV_MinMaxUInt(pDX, m_TrackRedBalance, 0, 100);
    DDX_Text(pDX, IDC_EDIT_TRACK_CAMERA_ANGLE, m_TrackCameraAngle);
    DDX_Check(pDX, IDC_CHECK_BEAMVIEW, m_DisplayBeamView);
    DDX_Text(pDX, IDC_EDIT_FOCUS_TRACK_REPEAT, m_FocusTrackRepeat);
    //}}AFX_DATA_MAP
}

////////////////////////////////////////////////////////////////////
//
// CCheap3DView::PreCreateWindow()
//
////////////////////////////////////////////////////////////////////
BOOL CCheap3DView::PreCreateWindow(CREATESTRUCT& cs)
{
    // TODO: Modify the Window class or styles here by modifying
    //  the CREATESTRUCT cs

    return CFormView::PreCreateWindow(cs);
}

////////////////////////////////////////////////////////////////////
//
// CCheap3DView Diagnostics
//
////////////////////////////////////////////////////////////////////
#ifdef _DEBUG
void 
CCheap3DView::AssertValid() const
{
    CFormView::AssertValid();
}

void 
CCheap3DView::Dump(CDumpContext& dc) const
{
    CFormView::Dump(dc);
}

CCheap3DDoc* 
CCheap3DView::GetDocument() // non-debug version is inline
{
    ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CCheap3DDoc)));
    return (CCheap3DDoc*)m_pDocument;
}
#endif //_DEBUG

////////////////////////////////////////////////////////////////////
//
// CCheap3DView message handlers
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//
// CCheap3DView::OnPaint()
//
////////////////////////////////////////////////////////////////////
void CCheap3DView::OnPaint() 
{
    CPaintDC dc(this); // device context for painting
    
    // start my code
    CleanViewPort();
    SetCleanDisplayTimer();
    // NOTE: Do not call CFormView::OnPaint() for painting messages

} // end CCheap3DView::OnPaint()

////////////////////////////////////////////////////////////////////
//
// 	CCheap3DView::OnTimer()
//
////////////////////////////////////////////////////////////////////
void CCheap3DView::OnTimer(UINT nIDEvent) 
{
#ifdef CHEAP3DVIEW_LOG_INFO
    logFile << "Entering OnTimer()" << endl;
#endif
    M_UINT16 midiEventProcessed = M_FALSE;

    switch(nIDEvent)
    {
        case PLAYBACK_TIMER:
        {
            ++playbackTime;
            SetPlaybackTimerPane((long)playbackTime);
        }
        break;

        case DISPLAY_TIMER:
        {
#ifndef REDUCED_MIDI_LATENCY
            if (midiPtr && midiPtr->EventsInBuffer())
            {
                // process next queued MIDI message
                midiEventProcessed = ProcessMidiEvent();
            }
#endif
            if (midiPtr && midiPtr->WaitingForEvent())
            {
                // if we're waiting for a followup MIDI
                // event (generally a NOTEOFF), do whatever
                // we need to do while we're waiting...
                midiEventProcessed = ProcessMidiWaitForContinuation();
            }

            if (midiEventProcessed && 
                (!liveDialog || (liveDialog && liveDialog->GetQueButtonStatus() == M_FALSE)))
            {
                DisplayAllTracks();
            }				
            else if (!scriptActive)
            {
                DisplayAllTracks();
            }
            else
            {
                if (!commandInProgress)
                {
                    if (ctsFilePtr)
                    {
                        ReadCtsFile();
                    }
                }
                else
                {
                    DisplayAllTracks();
                }
            }

            if (liveDialog)
            {
                liveDialog->SetQueButtonStatus(M_FALSE);
            }
        }
            break;

        case POINTS_PER_SECOND_TIMER:
        {
            // Here we take the opportunity to reset the
            // last known drag and rotate angles.  We do
            // this so that when the user drags the object
            // to rotate and then comes to a stop while
            // still holding down the mouse button, there
            // is no inertia calculated.  Put another way,
            // there should be no inertia to process if the
            // mouse has come to a stop prior to the mouse
            // button being released.  Why do we do it here,
            // of all places?  Because the PPS timer was
            // already in place, and provided a convenient
            // periodic opportunity to do the work.
            if(dragObjectPtr && !(dragObjectPtr->inertiaRemaining))
            {
                for (int i=FIRST_TRACK ; i<=MAX_TRACKS ; ++i)
                {
                    dragObjectPtr->trackItems[i-1].lastDragXdiff = 0;
                    dragObjectPtr->trackItems[i-1].lastDragYdiff = 0;
                    dragObjectPtr->trackItems[i-1].lastDragZdiff = 0;
                }
            }

            SetPointsPerSecondPane((long)((1000.0 / (double)PPS_TIMER_VALUE) * numPointsDisplayed));
            numPointsDisplayed = 0;

        }
            break;

        case CLEAN_DISPLAY_TIMER:
        {
            KillTimer(CLEAN_DISPLAY_TIMER);
            CleanViewPort();
        }
            break;

        default:
            break;

    } // end switch

    CFormView::OnTimer(nIDEvent);

} // end CCheap3DView::OnTimer()

////////////////////////////////////////////////////////////////////
//
// 	CCheap3DView::OnInitialUpdate()
//
////////////////////////////////////////////////////////////////////
// #pragma optimize("", off)
void CCheap3DView::OnInitialUpdate() 
{
    M_UINT8  i;
    M_UINT8  numberOutputDevices = 1;

#ifdef CHEAP3DVIEW_LOG_INFO
    logFile << "Entering CCheap3DView::OnInitialUpdate()" << endl;
#endif

    CFormView::OnInitialUpdate();
    
    // Set document title 
    CCheap3DDoc* pDoc = GetDocument();
    pDoc->SetTitle("");

    outputDeviceArray[0] = new Device_None();

#ifdef GWS_OUTPUT
    if (outputDeviceArray[0])
        delete outputDeviceArray[0];
    outputDeviceArray[0] = new Device_GWS(0x300);
#endif

#ifdef BSOFT_RGB_OUTPUT
    if (outputDeviceArray[0])
        delete outputDeviceArray[0];
    outputDeviceArray[0] = new Device_BSOFT_RGB(0x300);
#endif

#ifdef BSOFT_XYI_OUTPUT
    if (outputDeviceArray[0])
        delete outputDeviceArray[0];
    outputDeviceArray[0] = new Device_BSOFT_XYI(0x300);
#endif

    // ********** BEGIN EZAUDDAC SPECIFIC ************
#ifdef EZAUDDAC_OUTPUT
    if (outputDeviceArray[0])
        delete outputDeviceArray[0];
    outputDeviceArray[0] = new Device_EZAUDDAC(0);

    int numEadDevices = 0;
    // Call EzAudDacInit() for the first device which opens all devices and returns the number present
    numEadDevices = ((Device_EZAUDDAC*)(outputDeviceArray[0]))->EzAudDacInit();
    if (numEadDevices == 0)
    {
#ifdef CHEAP3DVIEW_LOG_ERROR
        logFile << "OnInitialUpdate(): Unable to initialize EzAudDac or no devices found" << endl;
#endif
        delete outputDeviceArray[0];
        outputDeviceArray[0] = new Device_None();
    }

    if (numEadDevices > 1)
    {
        outputDeviceArray[1] = new Device_EZAUDDAC(1);
    }
    else
    {
        outputDeviceArray[1] = new Device_None();
    }

    if (numEadDevices > 2)
    {
        outputDeviceArray[2] = new Device_EZAUDDAC(2);
    }
    else
    {
        outputDeviceArray[2] = new Device_None();
    }

    if (numEadDevices > 3)
    {
        outputDeviceArray[3] = new Device_EZAUDDAC(3);
    }
    else
    {
        outputDeviceArray[3] = new Device_None();
    }

#endif
    // ********** END EZAUDDAC SPECIFIC ************

#ifdef EASYLASE_OUTPUT
    if (outputDeviceArray[0])
        delete outputDeviceArray[0];
    outputDeviceArray[0] = new Device_EASYLASE(1, EASYLASE);
#endif

// ********** BEGIN RIYA SPECIFIC ************
#ifdef RIYA_OUTPUT
    M_UINT8 numRiyaDevices = 0;

    if (outputDeviceArray[0])
        delete outputDeviceArray[0];
    outputDeviceArray[0] = new Device_RIYA(0, RIYA);

    if (outputDeviceArray[0] &&
        outputDeviceArray[0]->GetOutputDeviceType() == RIYA)
    {
        // Need to call RiyaInit() for the first device prior to calling
        // GetRiyaNumberOfDevices()
        if(((Device_RIYA*)(outputDeviceArray[0]))->RiyaInit(0) == M_FAILURE )
        {
#ifdef CHEAP3DVIEW_LOG_ERROR
            logFile << "OnInitialUpdate(): Unable to initialize first RIYA device." << endl;
#endif
            delete outputDeviceArray[0];
            outputDeviceArray[0] = new Device_None();
        }
        else
        {
            numRiyaDevices = ((Device_RIYA*)outputDeviceArray[0])->GetRiyaNumberOfDevices();
            numberOutputDevices = numRiyaDevices;

            if (numRiyaDevices == 0)
            {
                delete outputDeviceArray[0];
                outputDeviceArray[0] = new Device_None();
            }
        }

    } // end if first device is RIYA
        
    if (numRiyaDevices > 1)
    {
        outputDeviceArray[1] = new Device_RIYA(1, RIYA);
    }
    else
    {
        outputDeviceArray[1] = new Device_None();
    }

    if (numRiyaDevices > 2)
    {
        outputDeviceArray[2] = new Device_RIYA(2, RIYA);
    }
    else
    {
        outputDeviceArray[2] = new Device_None();
    }

    if (numRiyaDevices > 3)
    {
        outputDeviceArray[3] = new Device_RIYA(3, RIYA);
    }
    else
    {
        outputDeviceArray[3] = new Device_None();
    }
#endif
    // ********** END RIYA SPECIFIC ************

      for(i=0 ; i<MAX_TRACKS ; ++i)
      {
        if (!outputDeviceArray[i])
        {
#ifdef CHEAP3DVIEW_LOG_ERROR
            logFile <<
            "OnInitialUpdate(): Unable to instantiate output device "
            << (M_UINT16)i << " object." << endl;
#endif
        }
    }

    gemLaserPtr = outputDeviceArray[DEFAULT_DEVICE];

    gemScreenPtr = new Device_None();

    strcpy(contentDirectoryName, "C:\\Laser\\");

    if (!gemScreenPtr)
    {
#ifdef CHEAP3DVIEW_LOG_ERROR
            logFile <<
            "OnInitialUpdate(): Unable to instantiate screen object." << endl;
#endif
    }

    if (!clientDCPtr)
    {
        clientDCPtr = new CClientDC(this);
    }

    // Set the parent frame pointer
    parentFramePtr = (CMainFrame*)GetParentFrame();

    // See if any MIDI devices are attached
    midiPtr = new Midi(this->m_hWnd);

    CString strMIDI;
    if (midiPtr && midiPtr->Ok())
    {
#ifdef BASIC_LOG_INFO
        logFile << "Midi object successfully created and initialized." << endl;
#endif
        SetMidiDevicePane(midiPtr->GetNumberOfMidiDevices());
    }
    else
    {
#ifdef BASIC_LOG_INFO
        logFile << "No MIDI devices opened." << endl;
#endif
        SetMidiDevicePane(0);

        if (midiPtr)
        {
            delete midiPtr;
            midiPtr = 0;
        }
    }

    FontList::InitFontList();
    FontList::SetFontList(DEFAULT_FONT);

    char fontFileName[_MAX_PATH];

    strcpy(fontFileName, appDirName);
    strcat(fontFileName, "\\default_font.ild\0");

    if (FontList::ReadFontFile(fontFileName) == M_FAILURE)
    {
#ifdef BASIC_LOG_INFO
        logFile << "Unable to successfully read in font file " << fontFileName << endl;
#endif
    }

    numFramesToWrite = 350;
    recordPaletteType = PaletteType::PANGOLIN;
    recordViewType = EYE;

    SetPointsPerSecondPane(0);
    numPointsDisplayed = 0;

    m_ILDA_Palette_Button = (int)PaletteType::PANGOLIN;

    fadeInFrames  = 1;
    fadeOutFrames = 1;
    colorIntensity = 100;
    globalFrameRepeat = 0;

    m_SliderBlankDelay.SetRange(0, 100);
    m_SliderBlankDelay.SetTicFreq(10);
    m_BlankingDelay = 20;
    m_SliderBlankDelay.SetPos(m_BlankingDelay);

    laserScale = defaultLaserScale;
    verticalScale = defaultVerticalScale;
    globalTrackDelay = 0;

    m_SliderTrackRedBalance.SetRange(0, 100);
    m_SliderTrackRedBalance.SetTicFreq(10);
    m_TrackRedBalance = 100;
    m_SliderTrackRedBalance.SetPos(m_TrackRedBalance);

    m_SliderTrackGreenBalance.SetRange(0, 100);
    m_SliderTrackGreenBalance.SetTicFreq(10);
    m_TrackGreenBalance = 100;
    m_SliderTrackGreenBalance.SetPos(m_TrackGreenBalance);

    m_SliderTrackBlueBalance.SetRange(0, 100);
    m_SliderTrackBlueBalance.SetTicFreq(10);
    m_TrackBlueBalance = 100;
    m_SliderTrackBlueBalance.SetPos(m_TrackBlueBalance);

    m_SliderTrackCameraAngle.SetRange(45, 170);
    m_SliderTrackCameraAngle.SetTicFreq(12);
    m_TrackCameraAngle = 45;
    m_SliderTrackCameraAngle.SetPos(m_TrackCameraAngle);

    m_SliderTrackScale.SetRange(1, 100);
    m_SliderTrackScale.SetTicFreq(10);
    m_TrackScale = 100;
    m_SliderTrackScale.SetPos(m_TrackScale);

    m_SliderFocusTrackDelay.SetRange(MIN_TRACK_DELAY, MAX_TRACK_DELAY);
    m_SliderFocusTrackDelay.SetTicFreq(MAX_TRACK_DELAY/50);
    m_FocusTrackDelay = 0;
    m_SliderFocusTrackDelay.SetPos(m_FocusTrackDelay);

    m_SliderFocusTrackRepeat.SetRange(-1, MAX_FOCUS_REPEAT);
    m_SliderFocusTrackRepeat.SetTicFreq(MAX_FOCUS_REPEAT/10);
    m_FocusTrackRepeat = 0;
    m_SliderFocusTrackRepeat.SetPos(m_FocusTrackRepeat);

    m_TrackFocusButton = 0;
    m_PointsOnly = FALSE;
    m_Reverse = FALSE;
    m_DisplayBeamView = FALSE;
    outputPPS = 12000;

    moveIncrement = 1000;
    zoomIncrement = 1000;
    rotateIncrement = 5;
    dragSpeed       = 1;
    dragInertia     = 50;

    displayLaser  = FALSE;
    displayScreen = TRUE;
    flickerFree   = FALSE;
    blankClipView = FALSE;
    scriptRepeat  = TRUE;
    blankingShift = 0;

    masterRed   = 1.0;
    masterGreen = 1.0;
    masterBlue  = 1.0;

    ttlThresholdRed   = 0.5;
    ttlThresholdGreen = 0.5;
    ttlThresholdBlue  = 0.5;

    beamOriginX1 = 0.48;
    beamOriginY1 = 0.30;
    beamOriginX2 = 0.90;
    beamOriginY2 = 0.30;
    beamHeight1  = 0.1;
    beamHeight2  = 0.1;
    beamOn1      = TRUE;
    beamOn2      = FALSE;
    beamInvertX1 = FALSE;
    beamInvertX2 = TRUE;
    beamYagView  = FALSE;
    beamMode     = NORMAL;

    displayTimerSet = FALSE;
    playbackTime = 0;

    leftPreviewEdgePixels = 267;

    serialCommandIndex = 0;
    memset(serialCommandString,0x00,sizeof(serialCommandString)/sizeof(char));

    mainWindowRect.left   = MAIN_WINDOW_LEFT_DEFAULT;
    mainWindowRect.top    = MAIN_WINDOW_TOP_DEFAULT;
    mainWindowRect.right  = MAIN_WINDOW_RIGHT_DEFAULT;
    mainWindowRect.bottom = MAIN_WINDOW_BOTTOM_DEFAULT;

    CWnd* tempMainWnd = AfxGetMainWnd();

#ifdef LATEST_BLANKING_MOD
    lastValidNDC_X = 0.5;
    lastValidNDC_Y = 0.5;
#endif

    InitTrackVariables();

    gemLaserPtr->SetDeviceWindow(gemLaserPtr->GetDeviceMin(),
                                 gemLaserPtr->GetDeviceMax(),
                                 gemLaserPtr->GetDeviceMin(),
                                 gemLaserPtr->GetDeviceMax());

    gemScreenPtr->SetWindow(WORLD_MIN,WORLD_MAX,WORLD_MIN,WORLD_MAX);
    gemLaserPtr->SetWindow(WORLD_MIN,WORLD_MAX,WORLD_MIN,WORLD_MAX);

    gemScreenPtr->SetViewport(0.0, 1.0, 0.0, 1.0);
    gemLaserPtr->SetViewport(0.0, 1.0, 0.0, 1.0);

    if (-1 == _chdir(appDirName))
    {
#ifdef CHEAP3DVIEW_LOG_ERROR
            logFile <<
            "OnInitialUpdate(): Unable to change directory." << endl;
#endif
    }

    FILE*    iniFilePtr = 0;
    fopen_s(&iniFilePtr, "LFI_Player.ini","rb");

    BOOL readSuccess = TRUE;

    if (iniFilePtr)
    {
        // Note that we read everything into temporary variables
        // first, so that if the stored value retrieval fails,
        // we'll leave all of the default values intact.
        M_UINT16  portVal;
        M_UINT16  tempDisplayLaser;
        M_UINT16  tempDisplayScreen;
        M_UINT16  tempFlickerFree;
        M_UINT16  tempInvertBlanking;
        M_UINT16  tempScriptRepeat;
        BOOL      tempBlankClipView;
        M_UINT32  tempGlobalTrackDelay;
        UINT      tempLaserScale;
        UINT      tempVerticalScale;
        INT       tempBlankingShift;
        M_UINT32  tempDisplayTimerValue;
        M_UINT16  tempColorMode;
        M_UINT16  tempInvertBitmap;
        M_UINT16  tempNumberFramesToWrite;
        M_UINT16  tempRecordPaletteType;
        M_UINT16  tempRecordViewType;
        UINT	  tempFadeInFrames;
        UINT	  tempFadeOutFrames;
        UINT      tempColorIntensity;
        int       tempGlobalFrameRepeat;
        UINT	  tempMoveIncrement;
        UINT	  tempRotateIncrement;
        UINT	  tempZoomIncrement;
        UINT      tempDragSpeed;
        UINT      tempDragInertia;
        UINT      tempMasterRed;
        UINT      tempMasterGreen;
        UINT      tempMasterBlue;
        UINT      tempTTLThresholdRed;
        UINT      tempTTLThresholdGreen;
        UINT      tempTTLThresholdBlue;
        M_UINT32  tempPPS;
        double     tempBeamOriginX1;
        double     tempBeamOriginY1;
        double     tempBeamOriginX2;
        double     tempBeamOriginY2;
        double     tempBeamHeight1;
        double     tempBeamHeight2;
        BOOL      tempBeamOn1;
        BOOL      tempBeamOn2;
        BOOL      tempBeamInvertX1;
        BOOL      tempBeamInvertX2;
        BOOL      tempBeamYagView;
        int       tempBeamMode;
        char      tempContentDirectoryName[MAX_BASENAME_SIZE];
        RECT      tempRect;
        UINT      tempLeftPreviewEdgePixels;
        int       tempComportIndex;
        int       tempBaudrateIndex;
        int       tempDatabitsIndex;
        int       tempParityIndex;
        int       tempStopbitsIndex;
        int       tempHandshakeIndex;
        M_UINT16  tempUseSerialPort;

        // This "while" loop is intended to only execute once
        // (to read in the config file) but allows us to stop
        // reading the file and continue on immediately if we
        // encounter an error reading the file.
        while(1)
        {
        int  tempChar = ' ';
        char tempString[81];
        int  k=0;

        while(tempChar!='\n' && k<80 && tempChar!=EOF)
        {
            tempChar = getc(iniFilePtr);
            tempString[k++] = tempChar;
        }

        tempString[k] = 0;

        int compareReturn = strcmp(tempString, MinIniFileHeaderString);

        if (compareReturn < 0)
        {
            readSuccess = FALSE;
            break;
        }

        // retrieve output port base address
        tempChar = ' ';
        while(tempChar!='=' && tempChar!=EOF)
        {
            tempChar = getc(iniFilePtr);
        }

        if (!fscanf(iniFilePtr,"%d", &portVal))
        {
            readSuccess = FALSE;
            break;
        }

        // retrieve display laser mode flag
        tempChar = ' ';
        while(tempChar!='=' && tempChar!=EOF)
        {
            tempChar = getc(iniFilePtr);
        }

        if (!fscanf(iniFilePtr,"%d", &tempDisplayLaser))
        {
            readSuccess = FALSE;
            break;
        }

        // retrieve display screen mode flag
        tempChar = ' ';
        while(tempChar!='=' && tempChar!=EOF)
        {
            tempChar = getc(iniFilePtr);
        }

        if (!fscanf(iniFilePtr,"%d", &tempDisplayScreen))
        {
            readSuccess = FALSE;
            break;
        }

        // retrieve flicker free mode flag
        tempChar = ' ';
        while(tempChar!='=' && tempChar!=EOF)
        {
            tempChar = getc(iniFilePtr);
        }

        if (!fscanf(iniFilePtr,"%d", &tempFlickerFree))
        {
            readSuccess = FALSE;
            break;
        }

        // retrieve invert blanking flag
        tempChar = ' ';
        while(tempChar!='=' && tempChar!=EOF)
        {
            tempChar = getc(iniFilePtr);
        }

        if (!fscanf(iniFilePtr,"%d", &tempInvertBlanking))
        {
            readSuccess = FALSE;
            break;
        }

        // retrieve script repeat flag
        tempChar = ' ';
        while(tempChar!='=' && tempChar!=EOF)
        {
            tempChar = getc(iniFilePtr);
        }

        if (!fscanf(iniFilePtr,"%d", &tempScriptRepeat))
        {
            readSuccess = FALSE;
            break;
        }

        // retrieve the Blank/Clip view flag
        tempChar = ' ';
        while(tempChar!='=' && tempChar!=EOF)
        {
            tempChar = getc(iniFilePtr);
        }

        if (!fscanf(iniFilePtr,"%d", &tempBlankClipView))
        {
            readSuccess = FALSE;
            break;
        }

        // retrieve global track delay
        tempChar = ' ';
        while(tempChar!='=' && tempChar!=EOF)
        {
            tempChar = getc(iniFilePtr);
        }

        if (!fscanf(iniFilePtr,"%ld", &tempGlobalTrackDelay))
        {
            readSuccess = FALSE;
            break;
        }

        // retrieve global laser scale
        tempChar = ' ';
        while(tempChar!='=' && tempChar!=EOF)
        {
            tempChar = getc(iniFilePtr);
        }

        if (!fscanf(iniFilePtr,"%d", &tempLaserScale))
        {
            readSuccess = FALSE;
            break;
        }

        // retrieve vertical output scale
        tempChar = ' ';
        while(tempChar!='=' && tempChar!=EOF)
        {
            tempChar = getc(iniFilePtr);
        }

        if (!fscanf(iniFilePtr,"%d", &tempVerticalScale))
        {
            readSuccess = FALSE;
            break;
        }

        // retrieve blanking shift value
        tempChar = ' ';
        while(tempChar!='=' && tempChar!=EOF)
        {
            tempChar = getc(iniFilePtr);
        }

        if (!fscanf(iniFilePtr,"%d", &tempBlankingShift))
        {
            readSuccess = FALSE;
            break;
        }

        // retrieve display output timer value
        tempChar = ' ';
        while(tempChar!='=' && tempChar!=EOF)
        {
            tempChar = getc(iniFilePtr);
        }

        if (!fscanf(iniFilePtr,"%d", &tempDisplayTimerValue))
        {
            readSuccess = FALSE;
            break;
        }

        // retrieve the color mode
        tempChar = ' ';
        while(tempChar!='=' && tempChar!=EOF)
        {
            tempChar = getc(iniFilePtr);
        }

        if (!fscanf(iniFilePtr,"%d", &tempColorMode))
        {
            readSuccess = FALSE;
            break;
        }

        // retrieve the master red adjust value
        tempChar = ' ';
        while(tempChar!='=' && tempChar!=EOF)
        {
            tempChar = getc(iniFilePtr);
        }

        if (!fscanf(iniFilePtr,"%d", &tempMasterRed))
        {
            readSuccess = FALSE;
            break;
        }

        // retrieve the master green adjust value
        tempChar = ' ';
        while(tempChar!='=' && tempChar!=EOF)
        {
            tempChar = getc(iniFilePtr);
        }

        if (!fscanf(iniFilePtr,"%d", &tempMasterGreen))
        {
            readSuccess = FALSE;
            break;
        }

        // retrieve the master blue adjust value
        tempChar = ' ';
        while(tempChar!='=' && tempChar!=EOF)
        {
            tempChar = getc(iniFilePtr);
        }

        if (!fscanf(iniFilePtr,"%d", &tempMasterBlue))
        {
            readSuccess = FALSE;
            break;
        }

        // retrieve the red ttl threshold adjust value
        tempChar = ' ';
        while(tempChar!='=' && tempChar!=EOF)
        {
            tempChar = getc(iniFilePtr);
        }

        if (!fscanf(iniFilePtr,"%d", &tempTTLThresholdRed))
        {
            readSuccess = FALSE;
            break;
        }

        // retrieve the green ttl threshold adjust value
        tempChar = ' ';
        while(tempChar!='=' && tempChar!=EOF)
        {
            tempChar = getc(iniFilePtr);
        }

        if (!fscanf(iniFilePtr,"%d", &tempTTLThresholdGreen))
        {
            readSuccess = FALSE;
            break;
        }

        // retrieve the blue ttl threshold adjust value
        tempChar = ' ';
        while(tempChar!='=' && tempChar!=EOF)
        {
            tempChar = getc(iniFilePtr);
        }

        if (!fscanf(iniFilePtr,"%d", &tempTTLThresholdBlue))
        {
            readSuccess = FALSE;
            break;
        }

        // retrieve the display invert flags
        tempChar = ' ';
        while(tempChar!='=' && tempChar!=EOF)
        {
            tempChar = getc(iniFilePtr);
        }

        if (!fscanf(iniFilePtr,"%d", &tempInvertBitmap))
        {
            readSuccess = FALSE;
            break;
        }

        // retrieve the number of frames to write when outputting ILDA
        tempChar = ' ';
        while(tempChar!='=' && tempChar!=EOF)
        {
            tempChar = getc(iniFilePtr);
        }

        if (!fscanf(iniFilePtr,"%d", &tempNumberFramesToWrite))
        {
            readSuccess = FALSE;
            break;
        }

        // retrieve the color palette to use when outputting ILDA
        tempChar = ' ';
        while(tempChar!='=' && tempChar!=EOF)
        {
            tempChar = getc(iniFilePtr);
        }

        if (!fscanf(iniFilePtr,"%d", &tempRecordPaletteType))
        {
            readSuccess = FALSE;
            break;
        }

        // retrieve the type of view to use when outputting ILDA
        tempChar = ' ';
        while(tempChar!='=' && tempChar!=EOF)
        {
            tempChar = getc(iniFilePtr);
        }

        if (!fscanf(iniFilePtr,"%d", &tempRecordViewType))
        {
            readSuccess = FALSE;
            break;
        }

        // retrieve the number of fade in frames when beginning
        // display of an ILDA frame file in "manual" mode
        tempChar = ' ';
        while(tempChar!='=' && tempChar!=EOF)
        {
            tempChar = getc(iniFilePtr);
        }

        if (!fscanf(iniFilePtr,"%d", &tempFadeInFrames))
        {
            readSuccess = FALSE;
            break;
        }

        // retrieve the number of fade out frames when ending
        // display of an ILDA frame file in "manual" mode
        tempChar = ' ';
        while(tempChar!='=' && tempChar!=EOF)
        {
            tempChar = getc(iniFilePtr);
        }

        if (!fscanf(iniFilePtr,"%d", &tempFadeOutFrames))
        {
            readSuccess = FALSE;
            break;
        }

        // retrieve the global value for the number of times
        // each frame of date is displayed before proceeding to
        // the next
        tempChar = ' ';
        while(tempChar!='=' && tempChar!=EOF)
        {
            tempChar = getc(iniFilePtr);
        }

        if (!fscanf(iniFilePtr,"%d", &tempGlobalFrameRepeat))
        {
            readSuccess = FALSE;
            break;
        }

        // retrieve the global value for the master laser
        // color intensity
        tempChar = ' ';
        while (tempChar != '=' && tempChar != EOF)
        {
            tempChar = getc(iniFilePtr);
        }

        if (!fscanf(iniFilePtr, "%d", &tempColorIntensity))
        {
            readSuccess = FALSE;
            break;
        }

        // retrieve the move increment value for image manipulation
        // when displaying an ILDA frame file in "manual" mode
        tempChar = ' ';
        while(tempChar!='=' && tempChar!=EOF)
        {
            tempChar = getc(iniFilePtr);
        }

        if (!fscanf(iniFilePtr,"%d", &tempMoveIncrement))
        {
            readSuccess = FALSE;
            break;
        }

        // retrieve the rotate increment value for image manipulation
        // when displaying an ILDA frame file in "manual" mode
        tempChar = ' ';
        while(tempChar!='=' && tempChar!=EOF)
        {
            tempChar = getc(iniFilePtr);
        }

        if (!fscanf(iniFilePtr,"%d", &tempRotateIncrement))
        {
            readSuccess = FALSE;
            break;
        }

        // retrieve the zoom increment value for image manipulation
        // when displaying an ILDA frame file in "manual" mode
        tempChar = ' ';
        while(tempChar!='=' && tempChar!=EOF)
        {
            tempChar = getc(iniFilePtr);
        }

        if (!fscanf(iniFilePtr,"%d", &tempZoomIncrement))
        {
            readSuccess = FALSE;
            break;
        }

        // retrieve the image click and drag speed value
        tempChar = ' ';
        while(tempChar!='=' && tempChar!=EOF)
        {
            tempChar = getc(iniFilePtr);
        }

        if (!fscanf(iniFilePtr,"%d", &tempDragSpeed))
        {
            readSuccess = FALSE;
            break;
        }

        // retrieve the image click and drag inertia value
        tempChar = ' ';
        while(tempChar!='=' && tempChar!=EOF)
        {
            tempChar = getc(iniFilePtr);
        }

        if (!fscanf(iniFilePtr,"%d", &tempDragInertia))
        {
            readSuccess = FALSE;
            break;
        }

        // retrieve the output points per second
        tempChar = ' ';
        while(tempChar!='=' && tempChar!=EOF)
        {
            tempChar = getc(iniFilePtr);
        }

        if (!fscanf(iniFilePtr,"%d", &tempPPS))
        {
            readSuccess = FALSE;
            break;
        }

        // retrieve the beam view X origin for virtual projector 1
        tempChar = ' ';
        while(tempChar!='=' && tempChar!=EOF)
        {
            tempChar = getc(iniFilePtr);
        }

        if (!fscanf(iniFilePtr,"%lf", &tempBeamOriginX1))
        {
            readSuccess = FALSE;
            break;
        }

        // retrieve the beam view Y origin for virtual projector 1
        tempChar = ' ';
        while(tempChar!='=' && tempChar!=EOF)
        {
            tempChar = getc(iniFilePtr);
        }

        if (!fscanf(iniFilePtr,"%lf", &tempBeamOriginY1))
        {
            readSuccess = FALSE;
            break;
        }

        // retrieve the beam view X origin for virtual projector 2
        tempChar = ' ';
        while(tempChar!='=' && tempChar!=EOF)
        {
            tempChar = getc(iniFilePtr);
        }

        if (!fscanf(iniFilePtr,"%lf", &tempBeamOriginX2))
        {
            readSuccess = FALSE;
            break;
        }

        // retrieve the beam view Y origin for virtual projector 2
        tempChar = ' ';
        while(tempChar!='=' && tempChar!=EOF)
        {
            tempChar = getc(iniFilePtr);
        }

        if (!fscanf(iniFilePtr,"%lf", &tempBeamOriginY2))
        {
            readSuccess = FALSE;
            break;
        }

        // retrieve the beam height for virtual projector 1
        tempChar = ' ';
        while(tempChar!='=' && tempChar!=EOF)
        {
            tempChar = getc(iniFilePtr);
        }

        if (!fscanf(iniFilePtr,"%lf", &tempBeamHeight1))
        {
            readSuccess = FALSE;
            break;
        }

        // retrieve the beam height for virtual projector 2
        tempChar = ' ';
        while(tempChar!='=' && tempChar!=EOF)
        {
            tempChar = getc(iniFilePtr);
        }

        if (!fscanf(iniFilePtr,"%lf", &tempBeamHeight2))
        {
            readSuccess = FALSE;
            break;
        }

        // retrieve the beam on/off flag for virtual projector 1
        tempChar = ' ';
        while(tempChar!='=' && tempChar!=EOF)
        {
            tempChar = getc(iniFilePtr);
        }

        if (!fscanf(iniFilePtr,"%d", &tempBeamOn1))
        {
            readSuccess = FALSE;
            break;
        }

        // retrieve the beam on/off flag for virtual projector 2
        tempChar = ' ';
        while(tempChar!='=' && tempChar!=EOF)
        {
            tempChar = getc(iniFilePtr);
        }

        if (!fscanf(iniFilePtr,"%d", &tempBeamOn2))
        {
            readSuccess = FALSE;
            break;
        }

        // retrieve the X-axis invert on/off flag for virtual projector 1
        tempChar = ' ';
        while(tempChar!='=' && tempChar!=EOF)
        {
            tempChar = getc(iniFilePtr);
        }

        if (!fscanf(iniFilePtr,"%d", &tempBeamInvertX1))
        {
            readSuccess = FALSE;
            break;
        }

        // retrieve the X-axis invert on/off flag for virtual projector 2
        tempChar = ' ';
        while(tempChar!='=' && tempChar!=EOF)
        {
            tempChar = getc(iniFilePtr);
        }

        if (!fscanf(iniFilePtr,"%d", &tempBeamInvertX2))
        {
            readSuccess = FALSE;
            break;
        }

        // retrieve the beam view "YAG view" flag
        tempChar = ' ';
        while(tempChar!='=' && tempChar!=EOF)
        {
            tempChar = getc(iniFilePtr);
        }

        if (!fscanf(iniFilePtr,"%d", &tempBeamYagView))
        {
            readSuccess = FALSE;
            break;
        }

        // retrieve the beam view display mode
        tempChar = ' ';
        while(tempChar!='=' && tempChar!=EOF)
        {
            tempChar = getc(iniFilePtr);
        }

        if (!fscanf(iniFilePtr,"%d", &tempBeamMode))
        {
            readSuccess = FALSE;
            break;
        }

        // retrieve path to the base directory where the content
        // files (i.e. ILD, CTS, CLV, etc.) are located
        tempChar = ' ';
        while(tempChar!='=' && tempChar!=EOF)
        {
            tempChar = getc(iniFilePtr);
        }

        // MAX_BASENAME_SIZE
        if (!fscanf(iniFilePtr,"%s", tempContentDirectoryName))
        {
            readSuccess = FALSE;
            break;
        }

        // retrieve the pixel value of main window left edge
        tempChar = ' ';
        while(tempChar!='=' && tempChar!=EOF)
        {
            tempChar = getc(iniFilePtr);
        }

        if (!fscanf(iniFilePtr,"%ld", &(tempRect.left)))
        {
            readSuccess = FALSE;
            break;
        }

        // retrieve the pixel value of main window top edge
        tempChar = ' ';
        while(tempChar!='=' && tempChar!=EOF)
        {
            tempChar = getc(iniFilePtr);
        }

        if (!fscanf(iniFilePtr,"%ld", &(tempRect.top)))
        {
            readSuccess = FALSE;
            break;
        }

        // retrieve the pixel value of main window right edge
        tempChar = ' ';
        while(tempChar!='=' && tempChar!=EOF)
        {
            tempChar = getc(iniFilePtr);
        }

        if (!fscanf(iniFilePtr,"%ld", &(tempRect.right)))
        {
            readSuccess = FALSE;
            break;
        }

        // retrieve the pixel value of main window bottom edge
        tempChar = ' ';
        while(tempChar!='=' && tempChar!=EOF)
        {
            tempChar = getc(iniFilePtr);
        }

        if (!fscanf(iniFilePtr,"%ld", &(tempRect.bottom)))
        {
            readSuccess = FALSE;
            break;
        }

        // retrieve the pixel value of left preview window edge offset
        tempChar = ' ';
        while(tempChar!='=' && tempChar!=EOF)
        {
            tempChar = getc(iniFilePtr);
        }

        if (!fscanf(iniFilePtr,"%d", &tempLeftPreviewEdgePixels))
        {
            readSuccess = FALSE;
            break;
        }

        // retrieve the COM Port index
        tempChar = ' ';
        while(tempChar!='=' && tempChar!=EOF)
        {
            tempChar = getc(iniFilePtr);
        }

        if (!fscanf(iniFilePtr,"%d", &tempComportIndex))
        {
            readSuccess = FALSE;
            break;
        }

        // retrieve the Baud Rate index
        tempChar = ' ';
        while(tempChar!='=' && tempChar!=EOF)
        {
            tempChar = getc(iniFilePtr);
        }

        if (!fscanf(iniFilePtr,"%d", &tempBaudrateIndex))
        {
            readSuccess = FALSE;
            break;
        }

        // retrieve the Data Bits index
        tempChar = ' ';
        while(tempChar!='=' && tempChar!=EOF)
        {
            tempChar = getc(iniFilePtr);
        }

        if (!fscanf(iniFilePtr,"%d", &tempDatabitsIndex))
        {
            readSuccess = FALSE;
            break;
        }

        // retrieve the Parity index
        tempChar = ' ';
        while(tempChar!='=' && tempChar!=EOF)
        {
            tempChar = getc(iniFilePtr);
        }

        if (!fscanf(iniFilePtr,"%d", &tempParityIndex))
        {
            readSuccess = FALSE;
            break;
        }

        // retrieve the Stop Bits index
        tempChar = ' ';
        while(tempChar!='=' && tempChar!=EOF)
        {
            tempChar = getc(iniFilePtr);
        }

        if (!fscanf(iniFilePtr,"%d", &tempStopbitsIndex))
        {
            readSuccess = FALSE;
            break;
        }

        // retrieve the Hand Shake index
        tempChar = ' ';
        while(tempChar!='=' && tempChar!=EOF)
        {
            tempChar = getc(iniFilePtr);
        }

        if (!fscanf(iniFilePtr,"%d", &tempHandshakeIndex))
        {
            readSuccess = FALSE;
            break;
        }

        // retrieve the Use Serial Port flag
        tempChar = ' ';
        while(tempChar!='=' && tempChar!=EOF)
        {
            tempChar = getc(iniFilePtr);
        }

        if (!fscanf(iniFilePtr,"%d", &tempUseSerialPort))
        {
            readSuccess = FALSE;
            break;
        }

        // done reading...
        break;

        } // end read block

        if (readSuccess == FALSE)
        {
#ifdef CHEAP3DVIEW_LOG_ERROR
    logFile << "OnInitialUpdate(): Unable to read LFI_Player.ini, using defaults." << endl;
#endif
        }
        else
        {
// #ifdef CHEAP3DVIEW_LOG_INFO
        logFile << "Read the following values from LFI_Player.ini:" << "\n"
                << "          BasePort: 0x" << hex << portVal << dec << "\n"
                << "      DisplayLaser: " << tempDisplayLaser << "\n"
                << "     DisplayScreen: " << tempDisplayScreen << "\n"
                << "       FlickerFree: " << tempFlickerFree << "\n"
                << "    InvertBlanking: " << tempInvertBlanking << "\n"
                << "      ScriptRepeat: " << tempScriptRepeat << "\n"
                << "   Blank/Clip View: " << tempBlankClipView << "\n"
                << "       GlobalDelay: " << tempGlobalTrackDelay << "\n"
                << "        LaserScale: " << tempLaserScale << "\n"
                << "     VerticalScale: " << tempVerticalScale << "\n"
                << "     BlankingShift: " << tempBlankingShift << "\n"
                << "      DisplayTimer: " << tempDisplayTimerValue << "\n"
                << "         ColorMode: " << tempColorMode << "\n"
                << "         MasterRed: " << tempMasterRed << "\n"
                << "       MasterGreen: " << tempMasterGreen << "\n"
                << "        MasterBlue: " << tempMasterBlue << "\n"
                << "   TTLThresholdRed: " << tempTTLThresholdRed << "\n"
                << " TTLThresholdGreen: " << tempTTLThresholdGreen << "\n"
                << "  TTLThresholdBlue: " << tempTTLThresholdBlue << "\n"
                << "      InvertBitmap: " << tempInvertBitmap << "\n"
                << "      Frames2Write: " << tempNumberFramesToWrite << "\n"
                << "     RecordPalette: " << tempRecordPaletteType << "\n"
                << "        RecordView: " << tempRecordViewType << "\n"
                << "      FadeInFrames: " << tempFadeInFrames << "\n"
                << "     FadeOutFrames: " << tempFadeOutFrames << "\n"
                << " GlobalFrameRepeat: " << tempGlobalFrameRepeat << "\n"
                << "    ColorIntensity: " << tempColorIntensity << "\n"
                << "     MoveIncrement: " << tempMoveIncrement << "\n"
                << "   RotateIncrement: " << tempRotateIncrement << "\n"
                << "     ZoomIncrement: " << tempZoomIncrement << "\n"
                << "        Drag Speed: " << tempDragSpeed << "\n"
                << "       DragInertia: " << tempDragInertia << "\n"
                << " Points Per Second: " << tempPPS << "\n"
                << "    Beam X1 Origin: " << tempBeamOriginX1<< "\n"
                << "    Beam Y1 Origin: " << tempBeamOriginY1<< "\n"
                << "    Beam X2 Origin: " << tempBeamOriginX2<< "\n"
                << "    Beam Y2 Origin: " << tempBeamOriginY2<< "\n"
                << "     Beam 1 Height: " << tempBeamHeight1 << "\n"
                << "     Beam 2 Height: " << tempBeamHeight2 << "\n"
                << "         Beam 1 On: " << tempBeamOn1 << "\n"
                << "         Beam 2 On: " << tempBeamOn2 << "\n"
                << "   Beam 1 Invert X: " << tempBeamInvertX1 << "\n"
                << "   Beam 2 Invert X: " << tempBeamInvertX2 << "\n"
                << "     Beam YAG View: " << tempBeamYagView << "\n"
                << "         Beam Mode: " << tempBeamMode << "\n"
                << " Content Directory: " << &tempContentDirectoryName[0] << "\n"
                << "  Main Window Left: " << tempRect.left << "\n"
                << "   Main Window Top: " << tempRect.top << "\n"
                << " Main Window Right: " << tempRect.right << "\n"
                << "Main Window Bottom: " << tempRect.bottom << "\n"
                << " Left Preview Edge: " << tempLeftPreviewEdgePixels << "\n"
                << "    COM Port Index: " << tempComportIndex << "\n"
                << "   Baud Rate Index: " << tempBaudrateIndex << "\n"
                << "   Data Bits Index: " << tempDatabitsIndex << "\n"
                << "      Parity Index: " << tempParityIndex << "\n"
                << "   Stop Bits Index: " << tempStopbitsIndex << "\n"
                << "  Hand Shake Index: " << tempHandshakeIndex << "\n"
                << "   Use Serial Port: " << tempUseSerialPort << endl;

// #endif

           if(strcmp(tempContentDirectoryName,"___") == 0)
           {
               strcpy(contentDirectoryName, "\0");
           }
           else
           {
               strcpy(contentDirectoryName, tempContentDirectoryName);
           }
            
           gemLaserPtr->SetBasePort(portVal);
           displayLaser     = (BOOL)tempDisplayLaser;
           displayScreen    = (BOOL)tempDisplayScreen;
           flickerFree      = (BOOL)tempFlickerFree;
           invertBlanking   = (M_UINT16)tempInvertBlanking;
           scriptRepeat     = (BOOL)tempScriptRepeat;
           blankClipView    = (BOOL)tempBlankClipView;
           globalTrackDelay = tempGlobalTrackDelay;
           laserScale       = tempLaserScale;
           verticalScale    = tempVerticalScale;
           blankingShift    = tempBlankingShift;
           displayTimerValue  = tempDisplayTimerValue;
           colorMode          = (enum DisplayColorMode)tempColorMode;
           masterRed          = (double)tempMasterRed   / 100.0;
           masterGreen        = (double)tempMasterGreen / 100.0;
           masterBlue         = (double)tempMasterBlue  / 100.0;
           ttlThresholdRed    = (double)tempTTLThresholdRed   / 100.0;
           ttlThresholdGreen  = (double)tempTTLThresholdGreen / 100.0;
           ttlThresholdBlue   = (double)tempTTLThresholdBlue  / 100.0;
           invertBitmap       = tempInvertBitmap;
           numFramesToWrite   = tempNumberFramesToWrite;
           recordPaletteType  = (enum PaletteType)tempRecordPaletteType;
           recordViewType     = (enum DisplayViewType)tempRecordViewType;
           fadeInFrames       = tempFadeInFrames;
           fadeOutFrames      = tempFadeOutFrames;
           globalFrameRepeat  = tempGlobalFrameRepeat;
           colorIntensity     = tempColorIntensity;
           moveIncrement      = tempMoveIncrement;
           rotateIncrement    = tempRotateIncrement;
           zoomIncrement      = tempZoomIncrement;
           dragSpeed          = tempDragSpeed;
           dragInertia        = tempDragInertia;
           outputPPS          = tempPPS;
           beamOriginX1       = tempBeamOriginX1;
           beamOriginY1       = tempBeamOriginY1;
           beamOriginX2       = tempBeamOriginX2;
           beamOriginY2       = tempBeamOriginY2;
           beamHeight1        = tempBeamHeight1;
           beamHeight2        = tempBeamHeight2;
           beamOn1            = (BOOL)tempBeamOn1;
           beamOn2            = (BOOL)tempBeamOn2;
           beamInvertX1       = (BOOL)tempBeamInvertX1;
           beamInvertX2       = (BOOL)tempBeamInvertX2;
           beamYagView        = (BOOL)tempBeamYagView;
           beamMode           = (BeamViewMode_T)tempBeamMode;
           mainWindowRect.left   = tempRect.left;
           mainWindowRect.top    = tempRect.top;
           mainWindowRect.right  = tempRect.right;
           mainWindowRect.bottom = tempRect.bottom;
           leftPreviewEdgePixels = tempLeftPreviewEdgePixels;
           useSerialPort = tempUseSerialPort;

#ifdef BASIC_LOG_INFO
           logFile << "OnInitialUpdate(): Initial values restored." << endl;
#endif

           if (useSerialPort == M_TRUE)
           {
               // Open the serial port
               strComPort.Format(_T("COM%d"), tempComportIndex+1);
               if (serialPort.Open(strComPort,this) != ERROR_SUCCESS)
               {
                   AfxMessageBox(_T("Unable to open COM-port"),MB_ICONSTOP|MB_OK);
#ifdef CHEAP3DVIEW_LOG_ERROR
                   logFile << "OnInitialUpdate(): Unable to open COM-port." << endl;
#endif
               }
           }

           // Setup the COM port
           if (serialPort.Setup(indexToBaudrate(tempBaudrateIndex),
                                indexToDatabits(tempDatabitsIndex),
                                indexToParity(tempParityIndex),
                                indexToStopbits(tempStopbitsIndex)))
           {
#ifdef CHEAP3DVIEW_LOG_ERROR
               logFile << "OnInitialUpdate(): COM Setup() failed." << endl;
#endif
           }

           // Setup handshaking
           if (serialPort.SetupHandshaking(indexToHandshake(tempHandshakeIndex)))
           {
#ifdef CHEAP3DVIEW_LOG_ERROR
               logFile << "OnInitialUpdate(): COM SetupHandshaking() failed." << endl;
#endif
           }

       }
       
       fclose(iniFilePtr);
    }
    else
    {
#ifdef CHEAP3DVIEW_LOG_ERROR
    logFile << "OnInitialUpdate(): Unable to open LFI_Player.ini, using defaults." << endl;
#endif
    }
    
    // Need to save the following values, which may be altered by one
    // or more scripts, to the "default" variables.
    defaultLaserScale    = laserScale;
    defaultVerticalScale = verticalScale;
    defaultGlobalDelay   = globalTrackDelay;

    // Process the command line arguments... 
    if (appCmdLineInfo.ArgsPassedBitmap & CL_INPUTFILENAME_MASK)
    {
#ifdef BASIC_LOG_INFO
        logFile << "Command Line: Input File Name is [" << appCmdLineInfo.InputFileName << "]" << endl;
#endif
        int len = strlen(appCmdLineInfo.InputFileName);
        char fileExt[4];
        for(int n=0 ; n<3 ; ++n)
        {
            fileExt[n] = toupper(appCmdLineInfo.InputFileName[len-3+n]);
        }
        fileExt[3] = 0;
#ifdef BASIC_LOG_INFO
        logFile << "Command Line: Input File Name Extension is [" <<  fileExt << "]" << endl;
#endif

        if(strcmp(fileExt,"ILD")==0)
        {
            OpenIldaFile(appCmdLineInfo.InputFileName);
            OnDisplayPlay();
        }
        else if(strcmp(fileExt,"ABS")==0)
        {
            OpenAbsFile(appCmdLineInfo.InputFileName);
            OnDisplayPlay();
        }
        else if(strcmp(fileExt,"TXT")==0)
        {
            OpenTxtFile(appCmdLineInfo.InputFileName);
            OnDisplayPlay();
        }
        else if(strcmp(fileExt,"CTS")==0)
        {
            OpenCtsFile(appCmdLineInfo.InputFileName);
            OnDisplayPlay();
        }
        else if(strcmp(fileExt,"CLV")==0)
        {
            OpenClvFile(appCmdLineInfo.InputFileName);
            OnDisplayPlay();
        }        
    }

    if (appCmdLineInfo.ArgsPassedBitmap & CL_SCANRATE_MASK)
    {
#ifdef BASIC_LOG_INFO
        logFile << "Command Line: Scan Rate is " << appCmdLineInfo.ScanRate  << endl;
#endif
        if(appCmdLineInfo.ScanRate >= MIN_PPS && appCmdLineInfo.ScanRate <= MAX_PPS)
        {
//	         outputDelayPeriod = (UINT)((1.0/(double)(appCmdLineInfo.ScanRate))/0.00000003);
             outputPPS = appCmdLineInfo.ScanRate;
        }
    }

    if (appCmdLineInfo.ArgsPassedBitmap & CL_FRAMEDELAY_MASK)
    {
#ifdef BASIC_LOG_INFO
        logFile << "Command Line: Frame Delay is " << appCmdLineInfo.FrameDelay  << endl;
#endif
        if(appCmdLineInfo.FrameDelay >= MIN_DISPLAY_TIMER_VALUE && appCmdLineInfo.FrameDelay <= MAX_DISPLAY_TIMER_VALUE)
        {
             displayTimerValue = appCmdLineInfo.FrameDelay;
        }
    }

    if (appCmdLineInfo.ArgsPassedBitmap & CL_BLANKINGSHIFT_MASK)
    {
#ifdef BASIC_LOG_INFO
        logFile << "Command Line: Blanking Shift is " << appCmdLineInfo.BlankingShift  << endl;
#endif
        if(appCmdLineInfo.BlankingShift >= MIN_BLANKING_SHIFT && appCmdLineInfo.BlankingShift <= MAX_BLANKING_SHIFT)
        {
             blankingShift = appCmdLineInfo.BlankingShift;
        }
    }

    if (appCmdLineInfo.ArgsPassedBitmap & CL_INVERTBLANKING_MASK)
    {
#ifdef BASIC_LOG_INFO
        logFile << "Command Line: Invert Blanking" << endl;
#endif
        invertBlanking = M_TRUE;
    }

#ifdef MERCURY_ONLINE_TEST
    if (appCmdLineInfo.ArgsPassedBitmap & CL_NUMBEROFLOOPS_MASK)
    {
        logFile << "Command Line: Number of Loops is " << appCmdLineInfo.NumberOfLoops  << endl;
    }

    if (appCmdLineInfo.ArgsPassedBitmap & CL_MONOCHROMEOUTPUT_MASK)
    {
        logFile << "Command Line: Monochrome Output" << endl;
    }

    if (appCmdLineInfo.ArgsPassedBitmap & CL_ESTIMATEDDURATION_MASK)
    {
        logFile << "Command Line: Estimate Display Duration" << endl;
    }
#endif // end Mercury Online Test

    // now that we're done processing the command line info,
    // clear the flags...
    appCmdLineInfo.ArgsPassedBitmap = 0;

    M_UINT8 riyaNumInit = 0;

    // Now perform final device initialization
    for(i=0 ; i<numberOutputDevices ; ++i)
    {
        outputDeviceArray[i]->SetDeviceWindow(outputDeviceArray[i]->GetDeviceMin(),
                                              outputDeviceArray[i]->GetDeviceMax(),
                                              outputDeviceArray[i]->GetDeviceMin(),
                                              outputDeviceArray[i]->GetDeviceMax());

        outputDeviceArray[i]->SetWindow(WORLD_MIN,WORLD_MAX,WORLD_MIN,WORLD_MAX);

        outputDeviceArray[i]->SetViewport(0.0, 1.0, 0.0, 1.0);

        if(outputDeviceArray[i])
        {
    // ********** BEGIN RIYA SPECIFIC ************
#ifdef RIYA_OUTPUT
            if(outputDeviceArray[i]->GetOutputDeviceType() == RIYA &&
               riyaNumInit < numRiyaDevices)
            {
                M_UINT32 tempDelayPeriod = (UINT)((1.0/(double)outputPPS)/0.00000003); 
                ((Device_RIYA*)(outputDeviceArray[i]))->SetDelayPeriod(tempDelayPeriod);

// msvob 3/20/2022: Why isn't the following being done up around line 1123 (at the time of this comment)?
// Come back to this later...
                // first RIYA device has already had RiyaInit() called...
                if (i>0)
                {
                    if( ((Device_RIYA*)(outputDeviceArray[i]))->RiyaInit(riyaNumInit) == M_FAILURE )
                    {
#ifdef CHEAP3DVIEW_LOG_ERROR
                        logFile <<
                        "OnInitialUpdate(): Unable to initialize for RIYA card." << endl;
#endif
                    }
                }

                ++riyaNumInit;
            }
#endif
    // ********** END RIYA SPECIFIC ************

    // ********** BEGIN EZAUDDAC SPECIFIC ************
#ifdef EZAUDDAC_OUTPUT
            if (outputDeviceArray[i]->GetOutputDeviceType() == EZAUDDAC)
                ((Device_EZAUDDAC*)(outputDeviceArray[0]))->SetOutputPPS(outputPPS);
#endif
    // ********** END EZAUDDAC SPECIFIC ************

    // ********** BEGIN EASYLASE SPECIFIC ************
#ifdef EASYLASE_OUTPUT
    if (outputDeviceArray[i] &&
        outputDeviceArray[i]->GetOutputDeviceType() == EASYLASE)
    {
        ((Device_EASYLASE*)(outputDeviceArray[i]))->SetOutputPPS(outputPPS);

        // Need to call EasylaseInit() for the device
        if(((Device_EASYLASE*)(outputDeviceArray[i]))->EasyLaseInit() == M_FAILURE )
        {
#ifdef CHEAP3DVIEW_LOG_ERROR
            logFile << "OnInitialUpdate(): Unable to initialize EasyLase device." << endl;
#endif
        }
    }
#endif
   // ********** END EASYLASE SPECIFIC ************

        }

        (outputDeviceArray[i])->DisplayOff(invertBlanking, colorMode);
    }

    UINT  nID;
    UINT  nStyle;
    int   cxWidth; 

    parentFramePtr->m_wndStatusBar.GetPaneInfo(1, nID, nStyle, cxWidth);
    parentFramePtr->m_wndStatusBar.SetPaneInfo(1, nID, nStyle, 100);

    // parentFramePtr->m_wndStatusBar.GetStatusBarCtrl().SetBkColor(RGB(180,180,180));

    SetPlaybackTimerPane(0);

    SetAppStatusPane("Okay");
    UpdateData(FALSE);
    SetCleanDisplayTimer();

} // end CCheap3DView::OnInitialUpdate()
// #pragma optimize("", on)

////////////////////////////////////////////////////////////////////
//
// CCheap3DView::InitTrack()
//
////////////////////////////////////////////////////////////////////
void CCheap3DView::InitTrack(const Track::TrackType trackType) 
{
#ifdef CHEAP3DVIEW_LOG_INFO
    logFile << "Entering InitTrack()" << endl;
#endif

    // Set the view to reasonable default values.
    ViewType newView;
    InitializeCurrentView(newView);
    trackPtr->SetTrackView(newView);
    trackPtr->SetTrackType(trackType);
    trackPtr->SetTrackDevice(DEFAULT_DEVICE);

    // Also set the display parameters to reasonable defaults.
    DisplayParams newParams;

    if (appCmdLineInfo.ArgsPassedBitmap & CL_COLORPALETTE_MASK)
    {
        switch(appCmdLineInfo.ColorPaletteType)
        {
            case PaletteType::LASER_ILLUSIONS:
            {
                newParams.palettePtr = &LaserIllusionsColorPalette[0];
                m_ILDA_Palette_Button = (int)PaletteType::LASER_ILLUSIONS;    
            }
            break;

            case PaletteType::ILDA:
            {
                newParams.palettePtr = &IldaColorPalette[0];
                m_ILDA_Palette_Button = (int)PaletteType::ILDA;
            }
            break;

            case PaletteType::X29:
            {
                newParams.palettePtr = &X29ColorPalette[0];
                m_ILDA_Palette_Button = (int)PaletteType::X29;
            }
            break;

            case PaletteType::PANGOLIN:
            {
                newParams.palettePtr = &PangolinColorPalette[0];
                m_ILDA_Palette_Button = (int)PaletteType::PANGOLIN;
            }
            break;

            default:
            {
                newParams.palettePtr = &PangolinColorPalette[0];
                m_ILDA_Palette_Button = (int)PaletteType::PANGOLIN;
            }
            break;
        }
    }
    else
    {
        // Set Default Color Palette
        newParams.palettePtr = &PangolinColorPalette[0];
        m_ILDA_Palette_Button = (int)PaletteType::PANGOLIN;
    }

    newParams.displayMode      = DISPLAY_ON;
    newParams.displayReverse   = M_FALSE;
    newParams.displayBeamView  = M_FALSE;
    newParams.delayValue       = 0;
    newParams.blankingDelay    = 4;
    newParams.colorFactor      = 0.0;
    newParams.redLevel         = 1.0;
    newParams.greenLevel       = 1.0;
    newParams.blueLevel        = 1.0;
    newParams.repeatCount      = 0;
    newParams.frameRepeat      = 0;
    newParams.trackScale       = 90;
    newParams.startFrameNumber = -1;
    newParams.fadeFramesIn     = 1;
    newParams.fadeFramesOut    = 1;

    m_FocusTrackDelay = newParams.delayValue;
    m_SliderFocusTrackDelay.SetPos(m_FocusTrackDelay);

    m_BlankingDelay = newParams.blankingDelay;
    m_SliderBlankDelay.SetPos(m_BlankingDelay);

    m_FocusTrackRepeat = newParams.frameRepeat;
    m_SliderFocusTrackRepeat.SetPos(m_FocusTrackRepeat);

    m_TrackRedBalance = (UINT)(newParams.redLevel * 100);
    m_SliderTrackRedBalance.SetPos(m_TrackRedBalance);

    m_TrackGreenBalance = (UINT)(newParams.greenLevel * 100);
    m_SliderTrackGreenBalance.SetPos(m_TrackGreenBalance);

    m_TrackBlueBalance = (UINT)(newParams.blueLevel * 100);
    m_SliderTrackBlueBalance.SetPos(m_TrackBlueBalance);

    m_TrackCameraAngle = (UINT)(newView.view_angle);
    m_SliderTrackCameraAngle.SetPos(m_TrackCameraAngle);

    m_TrackScale = newParams.trackScale;
    m_SliderTrackScale.SetPos(m_TrackScale);

    m_Reverse = FALSE;
    m_PointsOnly = FALSE;
    m_DisplayBeamView = FALSE;

    trackPtr->SetTrackParams(newParams);
    SetAppStatusPane("Okay");

} // end CCheap3DView::InitTrack()

////////////////////////////////////////////////////////////////////
//
// 	CCheap3DView::OpenIldaFile()
//
////////////////////////////////////////////////////////////////////
void CCheap3DView::OpenIldaFile(char* fileName) 
{
#ifdef CHEAP3DVIEW_LOG_INFO
    logFile << "Entering OpenIldaFile()" << endl;
#endif

    FrameSequence* frameSeqPtr = 0;

    if (DoReadILDAFile(fileName, &frameSeqPtr) == M_FAILURE)
    {
        MessageBox("OnOpenIldaFile(): Unable to open or read ILDA file.");
        return;
    }

    // Set document title 
    CCheap3DDoc* pDoc = GetDocument();
    pDoc->SetTitle(&fileName[0]);

    trackPtr = frameSeqPtr;
    InitTrack(Track::ILDA);
            
    // Add the sequence to the list.
    trackList.AddTrack(frameSeqPtr);

    // if this is the first track, set things up so all we
    // have to do is press the play button
    if (trackList.GetNumberOfTracks() == 1)
    {
        SetTrackArmState(1, ARM_TRACK);
        OnCheckDisplay1();
    }

    m_TrackFocusButton = (trackList.GetCurrentTrackNumber()) - 1;

    UpdateData(FALSE);

    if (abstractDialog)
    {
        abstractDialog->InitControlSettings();
    }

}  // end CCheap3DView::OpenIldaFile()

////////////////////////////////////////////////////////////////////
//
// CCheap3DView::OpenAbsFile()
//
////////////////////////////////////////////////////////////////////
void CCheap3DView::OpenAbsFile(char* fileName) 
{
#ifdef CHEAP3DVIEW_LOG_INFO
    logFile << "Entering OpenAbsFile()" << endl;
#endif

//    Abstract* absPtr = new Abstract(&fileName[0]);
    trackPtr = new Abstract(&fileName[0]);

    if (!trackPtr)
    {
        MessageBox("OnOpenAbsFile(): Unable to new Abstract object.");
        return;
    }

    if (!((Abstract*)trackPtr)->Ok())
    {
        MessageBox("OnOpenAbsFile(): Unable to correctly initialize Abstract object.");
        if (trackPtr)
        {
            delete trackPtr;
            trackPtr = 0;
        }
        return;
    }

    // Set document title 
    CCheap3DDoc* pDoc = GetDocument();
    pDoc->SetTitle(&fileName[0]);
            
    if (trackPtr->SetPattern(1) != M_SUCCESS)
    {
        MessageBox("OnOpenAbsFile(): Call to	Abstract::SetPattern() failed.");
        if (trackPtr)
        {
            delete trackPtr;
            trackPtr = 0;
        }
        return;
    }

    InitTrack(Track::ABSTRACT);

    // Add the sequence to the list.
    trackList.AddTrack(trackPtr);

    // if this is the first track, set things up so all we
    // have to do is press the play button
    if (trackList.GetNumberOfTracks() == 1)
    {
        SetTrackArmState(1, ARM_TRACK);
        OnCheckDisplay1();
    }

    if (abstractDialog)
    {
        SetTrackFocus(trackList.GetCurrentTrackNumber());   
    }
    else
    {
        m_TrackFocusButton = (trackList.GetCurrentTrackNumber()) - 1;
    }

    UpdateData(FALSE);
    
} // end CCheap3DView::OpenAbsFile()

////////////////////////////////////////////////////////////////////
//
// 	CCheap3DView::OpenTxtFile()
//
////////////////////////////////////////////////////////////////////
void CCheap3DView::OpenTxtFile(char* fileName) 
{
#ifdef CHEAP3DVIEW_LOG_INFO
    logFile << "Entering OpenTxtFile()" << endl;
#endif

    TextScroll* textScrollPtr = new TextScroll();

    if (!textScrollPtr)
    {
        MessageBox("OnOpenTextFile(): Unable to create Scrolling Text object.");
        return;        
    }

    FILE* textFilePtr;
    fopen_s(&textFilePtr, fileName, "rb");

    if (!textFilePtr)
    {
        MessageBox("OnOpenTextFile(): failed to open file for reading.");
        return;
    }

    if (textScrollPtr->ReadTextFile(textFilePtr) == M_FAILURE)
    {
        MessageBox("OnOpenTextFile(): Unable to read Text file.");
        return;
    }

    fclose(textFilePtr);

    // Set document title 
    CCheap3DDoc* pDoc = GetDocument();
    pDoc->SetTitle(&fileName[0]);

    trackPtr = textScrollPtr;
    InitTrack(Track::TEXT);
            
    // Add the sequence to the list.
    trackList.AddTrack(textScrollPtr);

    // if this is the first track, set things up so all we
    // have to do is press the play button
    if (trackList.GetNumberOfTracks() == 1)
    {
        SetTrackArmState(1, ARM_TRACK);
        OnCheckDisplay1();
    }

    m_TrackFocusButton = (trackList.GetCurrentTrackNumber()) - 1;

    UpdateData(FALSE);

    if (abstractDialog)
    {
        abstractDialog->InitControlSettings();
    }
    
} // end CCheap3DView::OpenTxtFile()

////////////////////////////////////////////////////////////////////
//
// 	CCheap3DView::OpenCtsFile()
//
////////////////////////////////////////////////////////////////////
void CCheap3DView::OpenCtsFile(char* fileName) 
{
#ifdef CHEAP3DVIEW_LOG_INFO
    logFile << "Entering OpenCtsFile()" << endl;
#endif

    fopen_s(&ctsFilePtr, fileName, "rb");

    if (!ctsFilePtr)
    {
        MessageBox("OnOpenCtsFile(): failed to open file for reading.");
        return;
    }

    // Set document title 
    CCheap3DDoc* pDoc = GetDocument();
    pDoc->SetTitle(&fileName[0]);
            
    // Indicate we're starting fresh so must look at file header.
    firstTime = M_TRUE;
       
    scriptActive = M_TRUE;

    if (abstractDialog)
    {
        abstractDialog->InitControlSettings();
    }

} // end CCheap3DView::OpenCtsFile()

////////////////////////////////////////////////////////////////////
//
// CCheap3DView::OpenClvFile()
//
////////////////////////////////////////////////////////////////////
void CCheap3DView::OpenClvFile(char* fileName) 
{
#ifdef CHEAP3DVIEW_LOG_INFO
    logFile << "Entering OpenClvFile()" << endl;
#endif

    M_UINT16 firstPass = M_FALSE;

    if (!liveDialog)
    {
#ifdef CHEAP3DVIEW_LOG_INFO
        logFile << "OnOpenClvFile(): Creating dialog" << endl;
#endif
        liveDialog = new CLiveControl(this);
        firstPass = M_TRUE;
    }
    else
    {
        liveDialog->EmptyTables();
    }

    if (ctsFilePtr)
    {
        AbortScript();
    }

    if (firstPass == M_TRUE)
    {
        liveDialog->Create(IDD_LIVE_CONTROL_DIALOG, this);
    }

    if (liveDialog->ReadCLVFile(fileName) == M_FAILURE)
    {
        MessageBox("OnOpenClvFile(): failed to open file for reading.");
        if (liveDialog)
        {
            delete(liveDialog);
            liveDialog = 0;
        }
        return;
    }

    // Set document title 
    CCheap3DDoc* pDoc = GetDocument();
    pDoc->SetTitle(&fileName[0]);
            
    if (abstractDialog)
    {
        abstractDialog->InitControlSettings();
    }

} // end CCheap3DView::OpenClvFile()

////////////////////////////////////////////////////////////////////
//
// 	CCheap3DView::OnOpenIldaFile()
//
////////////////////////////////////////////////////////////////////
void CCheap3DView::OnOpenIldaFile() 
{
#ifdef CHEAP3DVIEW_LOG_INFO
    logFile << "Entering OnOpenIldaFile()" << endl;
#endif

    char fileTitle[MAX_FILETITLE_SIZE];
    char fileName[MAX_FILENAME_SIZE];

    OPENFILENAME ofn;
    memset(&ofn, 0, sizeof(ofn));
    ofn.lStructSize = sizeof(OPENFILENAME);
    ofn.hwndOwner = NULL;
    ofn.hInstance = NULL;

    ofn.lpstrFilter =
    TEXT("ILDA laser display files *.ild\0*.ILD\0All Files *.*\0*.*\0\0");

    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter = 0;
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = fileName;
    ofn.nMaxFile = 500;
    ofn.lpstrFileTitle = fileTitle;
    ofn.nMaxFileTitle = 99;
    ofn.lpstrInitialDir = NULL;
    ofn.lpstrTitle = "Open ILDA File";
    ofn.Flags = OFN_FILEMUSTEXIST;
    ofn.lpstrDefExt = "ILD";
    ofn.lCustData = NULL;
    ofn.lpfnHook = NULL;
    ofn.lpTemplateName = NULL;

    fileName[0] = '\0';

    GetOpenFileName(&ofn);

    if (fileName[0] == '\0')
    {
#ifdef CHEAP3DVIEW_LOG_ERROR
    logFile << "OnOpenIldaFile(): GetOpenFileName() failed." << endl;
#endif
    return;
    }

    SetAppStatusPane("Loading");
    OpenIldaFile(&fileName[0]);
    SetAppStatusPane("Okay");

} // end CCheap3DView::OnOpenIldaFile()

////////////////////////////////////////////////////////////////////
//
// CCheap3DView::OnOpenAbsFile()
//
////////////////////////////////////////////////////////////////////
void CCheap3DView::OnOpenAbsFile() 
{
#ifdef BASIC_LOG_INFO
    logFile << "Entering OnOpenAbsFile()" << endl;
#endif

    char fileTitle[MAX_FILETITLE_SIZE];
    char fileName[MAX_FILENAME_SIZE];

    OPENFILENAME ofn;
    memset(&ofn, 0, sizeof(ofn));
    ofn.lStructSize = sizeof(OPENFILENAME);
    ofn.hwndOwner = NULL;
    ofn.hInstance = NULL;

    ofn.lpstrFilter =
    TEXT("LFI_Player abstract display files *.abs\0*.ABS\0All Files *.*\0*.*\0\0");

    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter = 0;
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = fileName;
    ofn.nMaxFile = 500;
    ofn.lpstrFileTitle = fileTitle;
    ofn.nMaxFileTitle = 99;
    ofn.lpstrInitialDir = NULL;
    ofn.lpstrTitle = "Open ABS File";
    ofn.Flags = OFN_FILEMUSTEXIST;
    ofn.lpstrDefExt = "ABS";
    ofn.lCustData = NULL;
    ofn.lpfnHook = NULL;
    ofn.lpTemplateName = NULL;

    fileName[0] = '\0';

    GetOpenFileName(&ofn);

    if (fileName[0] == '\0')
    {
#ifdef CHEAP3DVIEW_LOG_ERROR
    logFile << "OnOpenAbsFile(): GetOpenFileName() failed." << endl;
#endif
    return;
    }

    SetAppStatusPane("Loading");
    OpenAbsFile(&fileName[0]);
    SetAppStatusPane("Okay");

} // end CCheap3DView::OnOpenAbsFile()

////////////////////////////////////////////////////////////////////
//
// 	CCheap3DView::OnOpenTxtFile()
//
////////////////////////////////////////////////////////////////////
void CCheap3DView::OnOpenTxtFile() 
{
#ifdef BASIC_LOG_INFO
    logFile << "Entering OnOpenTxtFile()" << endl;
#endif

    if (!FontList::Ok())
    {
        MessageBox("Font not properly initialized; scrolling text is disabled.");
#ifdef CHEAP3DVIEW_LOG_ERROR
        logFile << "Font not properly initialized; scrolling text is disabled." << endl;
#endif
        return;
    }

    char fileTitle[MAX_FILETITLE_SIZE];
    char fileName[MAX_FILENAME_SIZE];

    OPENFILENAME ofn;
    memset(&ofn, 0, sizeof(ofn));
    ofn.lStructSize = sizeof(OPENFILENAME);
    ofn.hwndOwner = NULL;
    ofn.hInstance = NULL;

    ofn.lpstrFilter =
    TEXT("TEXT laser display files *.txt\0*.TXT\0All Files *.*\0*.*\0\0");

    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter = 0;
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = fileName;
    ofn.nMaxFile = 500;
    ofn.lpstrFileTitle = fileTitle;
    ofn.nMaxFileTitle = 99;
    ofn.lpstrInitialDir = NULL;
    ofn.lpstrTitle = "Open Text File";
    ofn.Flags = OFN_FILEMUSTEXIST;
    ofn.lpstrDefExt = "ILD";
    ofn.lCustData = NULL;
    ofn.lpfnHook = NULL;
    ofn.lpTemplateName = NULL;

    fileName[0] = '\0';

    GetOpenFileName(&ofn);

    if (fileName[0] == '\0')
    {
#ifdef CHEAP3DVIEW_LOG_ERROR
    logFile << "OnOpenTextFile(): GetOpenFileName() failed." << endl;
#endif
    return;
    }

    SetAppStatusPane("Loading");
    OpenTxtFile(&fileName[0]);
    SetAppStatusPane("Okay");


} // end CCheap3DView::OnOpenTxtFile()

////////////////////////////////////////////////////////////////////
//
// 	CCheap3DView::OnOpenCtsFile()
//
////////////////////////////////////////////////////////////////////
void CCheap3DView::OnOpenCtsFile() 
{
#ifdef BASIC_LOG_INFO
    logFile << "Entering OnOpenCtsFile()" << endl;
#endif

    char fileTitle[MAX_FILETITLE_SIZE];
    char fileName[MAX_FILENAME_SIZE];

    OPENFILENAME ofn;
    memset(&ofn, 0, sizeof(ofn));
    ofn.lStructSize = sizeof(OPENFILENAME);
    ofn.hwndOwner = NULL;
    ofn.hInstance = NULL;

    ofn.lpstrFilter =
    TEXT("3D script files *.cts\0*.CTS\0All Files *.*\0*.*\0\0");

    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter = 0;
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = fileName;
    ofn.nMaxFile = 500;
    ofn.lpstrFileTitle = fileTitle;
    ofn.nMaxFileTitle = 99;
    ofn.lpstrInitialDir = NULL;
    ofn.lpstrTitle = "Open 3D Script File";
    ofn.Flags = OFN_FILEMUSTEXIST;
    ofn.lpstrDefExt = "CTS";
    ofn.lCustData = NULL;
    ofn.lpfnHook = NULL;
    ofn.lpTemplateName = NULL;

    fileName[0] = '\0';

    GetOpenFileName(&ofn);

    if (fileName[0] == '\0')
    {
#ifdef CHEAP3DVIEW_LOG_ERROR
    logFile << "OnOpenCtsFile(): GetOpenFileName() failed." << endl;
#endif
    return;
    }

    SetAppStatusPane("Loading");
    OpenCtsFile(&fileName[0]);
    SetAppStatusPane("Okay");


} // end CCheap3DView::OnOpenCtsFile()

////////////////////////////////////////////////////////////////////
//
// CCheap3DView::OnOpenClvFile()
//
////////////////////////////////////////////////////////////////////
void CCheap3DView::OnOpenClvFile() 
{
#ifdef BASIC_LOG_INFO
    logFile << "Entering OnOpenClvFile()" << endl;
#endif

    char fileTitle[MAX_FILETITLE_SIZE];
    char fileName[MAX_FILENAME_SIZE];

    OPENFILENAME ofn;
    memset(&ofn, 0, sizeof(ofn));
    ofn.lStructSize = sizeof(OPENFILENAME);
    ofn.hwndOwner = NULL;
    ofn.hInstance = NULL;

    ofn.lpstrFilter =
    TEXT("3D live control files *.clv\0*.CLV\0All Files *.*\0*.*\0\0");

    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter = 0;
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = fileName;
    ofn.nMaxFile = 500;
    ofn.lpstrFileTitle = fileTitle;
    ofn.nMaxFileTitle = 99;
    ofn.lpstrInitialDir = NULL;
    ofn.lpstrTitle = "Open 3D Live Control File";
    ofn.Flags = OFN_FILEMUSTEXIST;
    ofn.lpstrDefExt = "CLV";
    ofn.lCustData = NULL;
    ofn.lpfnHook = NULL;
    ofn.lpTemplateName = NULL;

    fileName[0] = '\0';

    GetOpenFileName(&ofn);

    if (fileName[0] == '\0')
    {
#ifdef CHEAP3DVIEW_LOG_ERROR
    logFile << "OnOpenClvFile(): GetOpenFileName() failed." << endl;
#endif
        return;
    }

    SetAppStatusPane("Loading");
    OpenClvFile(&fileName[0]);
    SetAppStatusPane("Okay");

} // end CCheap3DView::OnOpenClvFile()

////////////////////////////////////////////////////////////////////
//
// CCheap3DView::OnFileClosetracklist()
//
////////////////////////////////////////////////////////////////////
void CCheap3DView::OnFileClosetracklist() 
{
#ifdef CHEAP3DVIEW_LOG_INFO
    logFile << "Entering OnFileClosetracklist()" << endl;
#endif

    KillTimer(DISPLAY_TIMER);
    displayTimerSet = FALSE;
    KillTimer(POINTS_PER_SECOND_TIMER);
    KillTimer(PLAYBACK_TIMER);
    playbackTime = 0;
    SetPlaybackTimerPane((long)playbackTime);
    CleanViewPort();
    SetPointsPerSecondPane(0);

    // in case displayLaser == FALSE but output not cleared
    for(M_UINT8 s=0 ; s<MAX_TRACKS ; ++s)
    {
        if(outputDeviceArray[s])
        {
            (outputDeviceArray[s])->DisplayOff(invertBlanking, colorMode);
        }
    }

    if (outFile)
    {
        if (frameNumPosArray)
        {
            if (currentFrameNumber < numFramesToWrite)
            {
                for (int i=0 ; i<currentFrameNumber ; ++i)
                {
                    fseek(outFile, frameNumPosArray[i], SEEK_SET);
                    PutWord(outFile, currentFrameNumber); 
                }
            }

            delete frameNumPosArray;
            frameNumPosArray = 0;
        }

        // Write file termination info...
        // BYTES 1 - 4: The ASCII characters "I" "L" "D" "A"
        fprintf(outFile,"%c%c%c%c",'I','L','D','A');

        // BYTES 5 - 7: Not used, but must be 0, 0, 0
        fprintf(outFile,"%c%c%c",0,0,0);

        // BYTE 8: Format Code
        fprintf(outFile, "%c", (M_UINT8)CCheap3DView::GetRecordFormatCode());

        // BYTES 9 - 16: Frame Name; 8 ASCII characters
        fprintf(outFile,"%c%c%c%c%c%c%c%c",'E','n','d',0,'0','0','0',0);

        // BYTES 17 - 24: Company Name; 8 ASCII characters
        fprintf(outFile,"%s","Lazerus ");

        // BYTES 25 - 26: Total Points; Total # of points in image
        fprintf(outFile,"%c%c",0,0);

        // BYTES 27 - 28: Frame number if part of sequence
        PutWord(outFile, currentFrameNumber);
        //fwrite(&currentFrameNumber,sizeof(M_INT16),1,outFile);

        // BYTES 29 - 30: Total Frames; Total frames in sequence
        PutWord(outFile, numFramesToWrite);
        //fwrite(&maxFramesToWrite,sizeof(M_INT16),1,outFile);

        // BYTE 31: Scanner Head; Scanner head or projector number
        fprintf(outFile,"%c", 0);

        // BYTE 32: Future; Must be set for binary zero
        fprintf(outFile,"%c", 0);

        fclose(outFile);
        outFile = 0;
        currentFrameNumber = 0;
        currentNumberPoints = 0;
    }
    else
    {
        scriptActive = M_FALSE;
        commandInProgress = M_FALSE;
        trackList.DeleteTrackList();

        if (abstractDialog)
        {
            abstractDialog->InitControlSettings();
        }

        if (!liveDialog && ctsFilePtr)
        {
            fclose(ctsFilePtr);
            ctsFilePtr = 0;
        }

        InitTrackVariables();

        globalTrackDelay = defaultGlobalDelay;
        laserScale       = defaultLaserScale;
        verticalScale    = defaultVerticalScale;
    }

    // Set document title 
    CCheap3DDoc* pDoc = GetDocument();
    pDoc->SetTitle("");
            
    UpdateData(FALSE);

} // end CCheap3DView::OnFileClosetracklist()

#ifdef LEGACY_OUTPUT
////////////////////////////////////////////////////////////////////
//
// CCheap3DView::OnOptionsSelectport()
//
////////////////////////////////////////////////////////////////////
void CCheap3DView::OnOptionsSelectport() 
{
#ifdef CHEAP3DVIEW_LOG_INFO
    logFile << "Entering OnOptionsSelectport()" << endl;
#endif

    CSelectPort selectDialog(this);
    selectDialog.DoModal();

} // CCheap3DView::OnOptionsSelectport()
#endif

////////////////////////////////////////////////////////////////////
//
// CCheap3DView::OnOptionsPreferences()
//
////////////////////////////////////////////////////////////////////
void CCheap3DView::OnOptionsPreferences() 
{
#ifdef CHEAP3DVIEW_LOG_INFO
    logFile << "Entering OnOptionsPreferences()" << endl;
#endif

    CPreferences*  preferencesDialog = new CPreferences(this);

    if (!preferencesDialog)
    {
#ifdef CHEAP3DVIEW_LOG_ERROR
        logFile << "OnOptionsPreferences(): Unable to new preferencesDialog." << endl;
#endif
        return;
    }

    if (preferencesDialog->Create() != IDOK)
    {
#ifdef CHEAP3DVIEW_LOG_ERROR
        logFile << "OnOptionsPreferences(): Create() failed." << endl;
#endif
        delete preferencesDialog;
        preferencesDialog = 0;
    }

} // CCheap3DView::OnOptionsPreferences()


////////////////////////////////////////////////////////////////////
//
// CCheap3DView::SetTrackDisplayValue()
//
////////////////////////////////////////////////////////////////////
void
CCheap3DView::SetTrackDisplayValue(M_UINT16 trackNum,
                                   BOOL   trackVal)
{
    switch(trackNum)
    {
        case 1:
        {
            m_DisplayTrack1 = trackVal;
        }
            break;
        case 2:
        {
            m_DisplayTrack2 = trackVal;
        }
            break;
        case 3:
        {
            m_DisplayTrack3 = trackVal;
        }
            break;
        case 4:
        {
            m_DisplayTrack4 = trackVal;
        }
            break;
        default:
            break;
    } // end switch on track number

} // end CCheap3DView::SetTrackDisplayValue

////////////////////////////////////////////////////////////////////
//
// CCheap3DView::SetTrackArmValue()
//
////////////////////////////////////////////////////////////////////
void
CCheap3DView::SetTrackArmValue(M_UINT16 trackNum,
                               BOOL   trackVal)
{
    switch(trackNum)
    {
        case 1:
        {
            m_ArmTrack1 = trackVal;
            m_EffectTrack1 = trackVal;
        }
            break;
        case 2:
        {
            m_ArmTrack2 = trackVal;
            m_EffectTrack2 = trackVal;
        }
            break;
        case 3:
        {
            m_ArmTrack3 = trackVal;
            m_EffectTrack3 = trackVal;
        }
            break;
        case 4:
        {
            m_ArmTrack4 = trackVal;
            m_EffectTrack4 = trackVal;
        }
            break;
        default:
            break;
    } // end switch on track number

} // end CCheap3DView::SetTrackArmValue

////////////////////////////////////////////////////////////////////
//
// CCheap3DView::SetCleanDisplayTimer()
//
////////////////////////////////////////////////////////////////////
void
CCheap3DView::SetCleanDisplayTimer(void)
{
    if (!SetTimer(CLEAN_DISPLAY_TIMER, 10, NULL))
    {
#ifdef CHEAP3DVIEW_LOG_ERROR
    logFile << "SetCleanDisplayTimer(): Can't install CLEAN_DISPLAY_TIMER." << endl;
#endif
    }

} // CCheap3DView::SetCleanDisplayTimer()

////////////////////////////////////////////////////////////////////
//
// CCheap3DView::SetTrackJobBlock()
//
////////////////////////////////////////////////////////////////////
void
CCheap3DView::SetTrackJobBlock(const JobBlock setJobBlock,
                               const M_UINT16   trackNumber)
{
    trackPtr = trackList.GetTrack(trackNumber);
    if (trackPtr)
    {
//		if (trackPtr->jobBlock.functionType != INVALID)
//		{
//            trackPtr->saveJobBlock = trackPtr->jobBlock;
//		}
        trackPtr->jobBlock = setJobBlock; 
    }

} // end CCheap3DView::SetTrackJobBlock()

    
////////////////////////////////////////////////////////////////////
//
// CCheap3DView::SetTracksJobBlocks()
//
////////////////////////////////////////////////////////////////////
void
CCheap3DView::SetTracksJobBlocks(const JobBlock setJobBlock)
{
    if (m_EffectTrack1 == TRUE)
    {
        trackPtr = trackList.GetTrack(1);
        if (trackPtr)
        {
            if (trackPtr->jobBlock.functionType != INVALID)
            {
                trackPtr->saveJobBlock = trackPtr->jobBlock;
            }
            trackPtr->jobBlock = setJobBlock; 
        }
    }
    if (m_EffectTrack2 == TRUE)
    {
        trackPtr = trackList.GetTrack(2);
        if (trackPtr)
        {
            if (trackPtr->jobBlock.functionType != INVALID)
            {
                trackPtr->saveJobBlock = trackPtr->jobBlock;
            }
            trackPtr->jobBlock = setJobBlock; 
        }
    }
    if (m_EffectTrack3 == TRUE)
    {
        trackPtr = trackList.GetTrack(3);
        if (trackPtr)
        {
            if (trackPtr->jobBlock.functionType != INVALID)
            {
                trackPtr->saveJobBlock = trackPtr->jobBlock;
            }
            trackPtr->jobBlock = setJobBlock; 
        }
    }
    if (m_EffectTrack4 == TRUE)
    {
        trackPtr = trackList.GetTrack(4);
        if (trackPtr)
        {
            if (trackPtr->jobBlock.functionType != INVALID)
            {
                trackPtr->saveJobBlock = trackPtr->jobBlock;
            }
            trackPtr->jobBlock = setJobBlock; 
        }
    }

} // end CCheap3DView::SetTracksJobBlocks()

////////////////////////////////////////////////////////////////////
//
// CCheap3DView::SetMidiDevicePane()
//
////////////////////////////////////////////////////////////////////
void
CCheap3DView::SetMidiDevicePane(M_UINT16 numMidiDevices)
{
    CString strMIDI;
    strMIDI.Format( "MIDI: %d", numMidiDevices);

#ifdef CLR_STATUS_BAR
    parentFramePtr->m_wndStatusBar.SetPaneTextClr(3,strMIDI, RGB(0,255,0), RGB(0,0,0));
    // parentFramePtr->m_wndStatusBar.PostMessage(SB_SETTEXT,3 | SBT_OWNERDRAW);
#else
    parentFramePtr->m_wndStatusBar.SetPaneText(3,strMIDI);
#endif
}

////////////////////////////////////////////////////////////////////
//
// CCheap3DView::SetPointPerSecondPane()
//
////////////////////////////////////////////////////////////////////
void
CCheap3DView::SetPointsPerSecondPane(long newPointsPerSecond)
{
    CString strPPS;
    strPPS.Format( "PPS: %d", newPointsPerSecond);

#ifdef CLR_STATUS_BAR
    parentFramePtr->m_wndStatusBar.SetPaneTextClr(2,strPPS, RGB(0,0,255), RGB(0,0,0));
    // parentFramePtr->m_wndStatusBar.PostMessage(SB_SETTEXT,2 | SBT_OWNERDRAW);
#else
    parentFramePtr->m_wndStatusBar.SetPaneText(2,strPPS);
#endif
}

////////////////////////////////////////////////////////////////////
//
// CCheap3DView::SetAppStatusPane()
//
////////////////////////////////////////////////////////////////////
void
CCheap3DView::SetAppStatusPane(CString newAppStatus)
{
#ifdef CLR_STATUS_BAR
    parentFramePtr->m_wndStatusBar.SetPaneTextClr(1,newAppStatus, RGB(255,0,0), RGB(0,0,0));
    // parentFramePtr->m_wndStatusBar.PostMessage(SB_SETTEXT,1 | SBT_OWNERDRAW);
#else
    parentFramePtr->m_wndStatusBar.SetPaneText(1,newAppStatus);
#endif

}

////////////////////////////////////////////////////////////////////
//
// CCheap3DView::SetPlaybackTimerPane()
//
////////////////////////////////////////////////////////////////////
void
CCheap3DView::SetPlaybackTimerPane(long playbackTime)
{
    CString strPBTime;
    strPBTime.Format( " %02d:%02d:%02d:%02d ",
                      playbackTime/360000,
                      (playbackTime/6000)%60,
                      (playbackTime/100)%60,
                      playbackTime%100);

#ifdef CLR_STATUS_BAR
    parentFramePtr->m_wndStatusBar.SetPaneTextClr(4,strPBTime, RGB(255,255,0), RGB(0,0,0));
    // parentFramePtr->m_wndStatusBar.PostMessage(SB_SETTEXT,4 | SBT_OWNERDRAW);
#else
    parentFramePtr->m_wndStatusBar.SetPaneText(4,strPBTime);
#endif

}

////////////////////////////////////////////////////////////////////
//
// CCheap3DView::OnLButtonDown()
//
////////////////////////////////////////////////////////////////////
void CCheap3DView::OnLButtonDown(UINT nFlags, CPoint point) 
{
//    if(scriptActive == FALSE)
//    {
//        CRect displayRect, offsetRect;
//        GetClientRect(&displayRect);
//        upperLeft  = displayRect.TopLeft();
//        lowerRight = displayRect.BottomRight();

        // adjust for offset of display window to right of controls
//		upperLeft.x = lowerRight.x-(lowerRight.y-upperLeft.y);
       
//        displayRect.SetRect(upperLeft.x,
//                            upperLeft.y,
//                            lowerRight.y-upperLeft.y,
//                            lowerRight.y-upperLeft.y);

        if(point.x >= upperLeft.x &&
           point.x <= lowerRight.x &&
           point.y >= upperLeft.y &&
           point.y <= lowerRight.y)
        {
            dragObjectPtr = new DragObject_T();
//            dragObjectPtr->displayRect = displayRect;
            dragObjectPtr->startPoint = point;
            dragObjectPtr->upperLeft = upperLeft;
            dragObjectPtr->lowerRight = lowerRight;
            dragObjectPtr->windowSize = lowerRight.x - upperLeft.x;
            dragObjectPtr->numberOfMoves = 0;
            dragObjectPtr->inertiaRemaining = 0;

            Track* tempTrackPtr;

            for (int i=FIRST_TRACK ; i<=MAX_TRACKS ; ++i)
            {

                tempTrackPtr = trackList.GetTrack(i);
                
                if (tempTrackPtr)
                {
                    dragObjectPtr->trackItems[i-1].originalView = tempTrackPtr->GetTrackView();
                    dragObjectPtr->trackItems[i-1].lastDragXangle = 0;
                    dragObjectPtr->trackItems[i-1].lastDragYangle = 0;
                    dragObjectPtr->trackItems[i-1].lastDragZangle = 0;
                    dragObjectPtr->trackItems[i-1].lastDragXdiff = 0;
                    dragObjectPtr->trackItems[i-1].lastDragYdiff = 0;
                    dragObjectPtr->trackItems[i-1].lastDragZdiff = 0;
                }
            }

        }
//    }

    CFormView::OnLButtonDown(nFlags, point);
}

////////////////////////////////////////////////////////////////////
//
// CCheap3DView::OnLButtonUp()
//
////////////////////////////////////////////////////////////////////
void CCheap3DView::OnLButtonUp(UINT nFlags, CPoint point) 
{

    if(dragObjectPtr)
    {
        // only setup for inertia if the mouse moved while
        // the button was pressed and the drag inertia user
        // preference is set for greater than zero (i.e.
        // make sure there's inertia to act on)
        if (dragObjectPtr->numberOfMoves &&
            dragInertia)  
        {      
            dragObjectPtr->inertiaRemaining = dragInertia;
        }
        else
        {
            delete dragObjectPtr;
            dragObjectPtr = 0;
        }
    }

    CFormView::OnLButtonUp(nFlags, point);
}

////////////////////////////////////////////////////////////////////
//
// CCheap3DView::OnMouseMove()
//
////////////////////////////////////////////////////////////////////
void CCheap3DView::OnMouseMove(UINT nFlags, CPoint point) 
{
    if(dragObjectPtr &&
       dragObjectPtr->inertiaRemaining == 0 &&
       point.x >= dragObjectPtr->upperLeft.x &&
       point.y >= dragObjectPtr->upperLeft.y &&
       point.x <= dragObjectPtr->lowerRight.x &&
       point.y <= dragObjectPtr->lowerRight.y)
    {
        double dragDivisor;

        switch (dragSpeed)
        {
            case 1:
                dragDivisor = .25;
                break;
            case 2:
                dragDivisor = .33333333333333;
                break;
            case 3:
                dragDivisor = .5;
                break;
            case 4:
                dragDivisor = 1;
                break;
            case 5:
                dragDivisor = 2;
                break;
            case 6:
                dragDivisor = 3;
                break;
            case 7:
                dragDivisor = 4;
                break;

            default:
                dragDivisor = 1;
                break;
        }

        double y_angle_raw = (360.0*dragDivisor) * ((double)(point.x-(dragObjectPtr->startPoint).x)/((double)dragObjectPtr->windowSize));
        double x_angle_raw = (360.0*dragDivisor) * ((double)(point.y-(dragObjectPtr->startPoint).y)/((double)dragObjectPtr->windowSize));

        double x_angle, y_angle, z_angle;
        ViewType tempView;
        Point3DType fromPoint;
        BOOL doEffect;
        JobBlock  tempJobBlock    = jobBlock;
        M_UINT16  tempTrackNumber = trackNumber;
        Track*    tempTrackPtr    = trackPtr;

        for (int i=FIRST_TRACK ; i<=MAX_TRACKS ; ++i)
        {
            switch(i)
            {
                case 1:
                    doEffect = m_EffectTrack1;
                    break;
                case 2:
                    doEffect = m_EffectTrack2;
                    break;
                case 3:
                    doEffect = m_EffectTrack3;
                    break;
                case 4:
                    doEffect = m_EffectTrack4;
                    break;
                default:
                    doEffect = FALSE;
            }

            trackNumber = i;
            trackPtr = trackList.GetTrack(trackNumber);
            if (trackPtr &&
                doEffect == TRUE &&
                trackPtr->saveJobBlock.functionType == INVALID)
            {
                tempView = dragObjectPtr->trackItems[i-1].originalView;
                trackPtr->SetTrackView(tempView);
                fromPoint = tempView.from_point;

                x_angle = -x_angle_raw;
                y_angle = -y_angle_raw;
                z_angle = -x_angle_raw;

                if (fromPoint.z == 0)
                {
                    x_angle = 0.0;
                }
                else if (fromPoint.x == 0)
                {
                    z_angle = 0.0;
                }       
                else if((abs(fromPoint.z) < abs(fromPoint.x)))
                {
                    x_angle = ((double)(abs(fromPoint.z)) / (double)(abs(fromPoint.x))) * -x_angle_raw;
                }
                else if((abs(fromPoint.x) < abs(fromPoint.z)))
                {
                    z_angle = ((double)(abs(fromPoint.x)) / (double)(abs(fromPoint.z))) * -x_angle_raw;
                }

                // +Z, +X
                if (fromPoint.x > 0 && fromPoint.z > 0)
                {
                    z_angle = -z_angle;
                }
                // +X, -Z
                else if (fromPoint.x > 0 && fromPoint.z < 0)
                {
                    x_angle = -x_angle;
                    z_angle = -z_angle;
                }
                // -X, -Z
                else if (fromPoint.x < 0 && fromPoint.z < 0)
                {
                    x_angle = -x_angle;
                }
                // else +Z, -X do nothing

                dragObjectPtr->trackItems[i-1].lastDragXdiff = x_angle - dragObjectPtr->trackItems[i-1].lastDragXangle;
                dragObjectPtr->trackItems[i-1].lastDragYdiff = y_angle - dragObjectPtr->trackItems[i-1].lastDragYangle;
                dragObjectPtr->trackItems[i-1].lastDragZdiff = z_angle - dragObjectPtr->trackItems[i-1].lastDragZangle;

                dragObjectPtr->trackItems[i-1].lastDragXangle = x_angle;
                dragObjectPtr->trackItems[i-1].lastDragYangle = y_angle;
                dragObjectPtr->trackItems[i-1].lastDragZangle = z_angle;

                jobBlock.functionType = ROTATE_FROM;
                jobBlock.numOfFrames = 1;
                jobBlock.rotationAxis = X_AXIS;
                jobBlock.degreeAngle = (x_angle);
                jobBlock.skipManipulation = M_TRUE;

                trackPtr->saveJobBlock = trackPtr->jobBlock;
                trackPtr->jobBlock = jobBlock; 

                DoTrackManipulation();

                jobBlock.functionType = ROTATE_FROM;
                jobBlock.numOfFrames = 1;
                jobBlock.rotationAxis = Z_AXIS;
                jobBlock.degreeAngle = (z_angle);
                jobBlock.skipManipulation = M_TRUE;
                trackPtr->jobBlock = jobBlock; 
                DoTrackManipulation();

                jobBlock.functionType = ROTATE_FROM;
                jobBlock.numOfFrames = 1;
                jobBlock.rotationAxis = Y_AXIS;
                jobBlock.degreeAngle = (y_angle);
//                if(scriptActive == M_FALSE)
//	                jobBlock.skipManipulation = M_FALSE;
//                else
                    jobBlock.skipManipulation = M_TRUE;

                trackPtr->jobBlock = jobBlock; 
                DoTrackManipulation();

            } // end if trackPtr & doEffect is TRUE

        } // end for loop through tracks

        jobBlock    = tempJobBlock;
        trackNumber = tempTrackNumber;
        trackPtr    = tempTrackPtr;

        ++dragObjectPtr->numberOfMoves;

    } // end if dragObjectPtr & point within window

    CFormView::OnMouseMove(nFlags, point);
}


////////////////////////////////////////////////////////////////////
//
// CCheap3DView::ProcessRemainingInertia()
//
////////////////////////////////////////////////////////////////////
void CCheap3DView::ProcessRemainingInertia(void) 
{
        double x_angle, y_angle, z_angle;
        BOOL doEffect;

        JobBlock  tempJobBlock    = jobBlock;
        JobBlock  trackSaveJobBlock;
        M_UINT16  tempTrackNumber = trackNumber;
        Track*    tempTrackPtr    = trackPtr;

        for (int i=FIRST_TRACK ; i<=MAX_TRACKS ; ++i)
        {
            switch(i)
            {
                case 1:
                    doEffect = m_EffectTrack1;
                    break;
                case 2:
                    doEffect = m_EffectTrack2;
                    break;
                case 3:
                    doEffect = m_EffectTrack3;
                    break;
                case 4:
                    doEffect = m_EffectTrack4;
                    break;
                default:
                    doEffect = FALSE;
            }

            trackNumber = i;
            trackPtr = trackList.GetTrack(trackNumber);
            if (trackPtr &&
                doEffect == TRUE)
            {
                x_angle = dragObjectPtr->trackItems[i-1].lastDragXdiff * ((double)dragObjectPtr->inertiaRemaining/dragInertia);
                y_angle = dragObjectPtr->trackItems[i-1].lastDragYdiff * ((double)dragObjectPtr->inertiaRemaining/dragInertia);
                z_angle = dragObjectPtr->trackItems[i-1].lastDragZdiff * ((double)dragObjectPtr->inertiaRemaining/dragInertia);


//                tempView = (dragObjectPtr->originalViewArray)[i-1];
//                trackPtr->SetTrackView(tempView);
//                fromPoint = tempView.from_point;
                trackSaveJobBlock = trackPtr->jobBlock;

                jobBlock.functionType = ROTATE_FROM;
                jobBlock.numOfFrames = 1;
                jobBlock.rotationAxis = X_AXIS;
                jobBlock.degreeAngle = (x_angle);
                jobBlock.skipManipulation = M_TRUE;

                trackSaveJobBlock = trackPtr->jobBlock;
                trackPtr->jobBlock = jobBlock; 

                DoTrackManipulation();

                jobBlock.functionType = ROTATE_FROM;
                jobBlock.numOfFrames = 1;
                jobBlock.rotationAxis = Z_AXIS;
                jobBlock.degreeAngle = (z_angle);
                jobBlock.skipManipulation = M_TRUE;
                trackPtr->jobBlock = jobBlock; 
                DoTrackManipulation();

                jobBlock.functionType = ROTATE_FROM;
                jobBlock.numOfFrames = 1;
                jobBlock.rotationAxis = Y_AXIS;
                jobBlock.degreeAngle = (y_angle);
//                if(scriptActive == M_FALSE)
//	                jobBlock.skipManipulation = M_FALSE;
//                else
                    jobBlock.skipManipulation = M_TRUE;

                trackPtr->jobBlock = jobBlock; 
                DoTrackManipulation();

                trackPtr->jobBlock = trackSaveJobBlock;

            } // end if trackPtr & doEffect is TRUE

        } // end for loop through tracks

        jobBlock    = tempJobBlock;
        trackNumber = tempTrackNumber;
        trackPtr    = tempTrackPtr;
}

////////////////////////////////////////////////////////////////////
//
// CCheap3DView::OnSerialMessage()
//
////////////////////////////////////////////////////////////////////
LRESULT CCheap3DView::OnSerialMsg (WPARAM wParam, LPARAM lParam)
{
    CSerial::EEvent eEvent = CSerial::EEvent(LOWORD(wParam));
    CSerial::EError eError = CSerial::EError(HIWORD(wParam));

    if (eError)
        logFile << "An internal error occurred." << endl;

/*	if (eEvent & CSerial::EEventBreak)
        logFile << "Break detected on input." << endl;

    if (eEvent & CSerial::EEventError)
        logFile << "A line-status error occurred." << endl;
    
    if (eEvent & CSerial::EEventRcvEv)
        logFile << "Event character has been received." << endl;

    if (eEvent & CSerial::EEventRing)
        logFile << "Ring detected" << endl;
    
    if (eEvent & CSerial::EEventSend)
        logFile << "All data is send" << endl;
    
    if (eEvent & CSerial::EEventCTS)
        logFile << "CTS signal change" << (M_UINT16)serialPort.GetCTS() << endl;
    
    if (eEvent & CSerial::EEventDSR)
        logFile << "DSR signal change" << (M_UINT16)serialPort.GetDSR() << endl;
    
    if (eEvent & CSerial::EEventRLSD)
        logFile << "RLSD signal change" << (M_UINT16)serialPort.GetRLSD() << endl; */
    
    if (eEvent & CSerial::EEventRecv)
    {
        // Create a clean buffer
        DWORD bytesRead;
        unsigned char szData[101];
        const int nBuflen = sizeof(szData)-1;

        // Obtain the data from the serial port
//		do
//		{
            serialPort.Read(szData,nBuflen,&bytesRead);
            szData[bytesRead] = '\0';

            // Scan the string for unwanted characters
            for (DWORD dwChar=0; dwChar<bytesRead; dwChar++)
            {
                if (!isprint(szData[dwChar]) && !isspace(szData[dwChar]))
                {
                    szData[dwChar] = '.';
                }

                if (szData[dwChar] == '\r' ||
                    szData[dwChar] == '\n' ||
                    szData[dwChar] == EOF)
                {
                    bytesRead = dwChar+1;
                    szData[bytesRead] = '\0';
                }
            }

            if (serialCommandIndex+bytesRead+1 < 101)
            {
                for (unsigned int n=0 ; n<bytesRead ; ++n)
                {
                   serialCommandString[serialCommandIndex++] = szData[n];
                }
            }


            SerialCommandT serialCommand = SERIAL_INVALID;
            M_UINT16 commandValue = 0;

            if (serialCommandString[serialCommandIndex-1] == '\r' ||
                serialCommandString[serialCommandIndex-1] == '\n' ||
                serialCommandString[serialCommandIndex-1] == EOF)
            {

                serialCommandString[serialCommandIndex] = '\0';
                char tempString[101];
                strcpy(tempString, serialCommandString);
                serialCommand = ProcessSerialString(&tempString[0], &commandValue);

                serialCommandIndex = 0;
            }

            if(serialCommand == SERIAL_PAGE ||
               serialCommand == SERIAL_CUE)
            {
//                logFile << "Command [" << serialCommand << "], Value [" << commandValue << "]" << endl;
                if(liveDialog)
                {
                    if(serialCommand == SERIAL_CUE)
                    {
                        liveDialog->DoButton(commandValue);
                    }
                    else
                    {
                        liveDialog->SetPage(commandValue);
                    }
                }

//			if (midiEventProcessed && 
            if((!liveDialog || (liveDialog && liveDialog->GetQueButtonStatus() == M_FALSE)))
            {
                DisplayAllTracks();
            }				
            else if (!scriptActive)
            {
                DisplayAllTracks();
            }
            else
            {
                if (!commandInProgress)
                {
                    if (ctsFilePtr)
                    {
                        ReadCtsFile();
                    }
                }
                else
                {
                    DisplayAllTracks();
                }
            }

            if (liveDialog)
            {
                liveDialog->SetQueButtonStatus(M_FALSE);
            }



            }

//		} while (dwRead == nBuflen);

    }

    return 0;

}

